{"id":"4","title":"Backbone Parte 1 - Model","by":"Diullei Gomes","tags":["JavaScript","Backbone","Model","View","Router"],"category":"JavaScript","date":"'2012-07-22'","deploy":"true","content":"##Introdução\r\n\r\nEste é o primeiro artigo de uma sério onde eu pretendo apresentar boas práticas e ferramentas que nos permitirão criar aplicações padronizadas, desacopladas, modulares e de fácil testabilidade. Utilizaremos a princípio os frameworks disponíveis: [Backbone](http://backbonejs.org/), [Jasmine DBB](http://pivotal.github.com/jasmine/), [Sinon.JS](http://sinonjs.org/), [KnockoutJs](http://knockoutjs.com/), [jQuery](http://jquery.com/), [Require.Js](http://requirejs.org/) entre outros. \r\n\r\n##Backbone\nTemos ouvido muito falar sobre Backbone ultimamente. Este framework ganhou favoritismo entre os desenvolvedores javascript e tem sido bastante utilizado por muitos. O Backbone não provê componentes de interface como widgets e controles customizaveis nos deixando livres para escolher com que framework UI iremos querer trabalhar. Ele se concentra apenas na infra estrutura do projeto. Com Backbone podemos escrever aplicativos bem organizados e fácil de ser testado. \r\n\r\nO código fonte fo Backbone é aberto e pode ser encontrado no github [neste](https://github.com/documentcloud/backbone/) endereço e a página oficial do Backbone pode ser acessada a partir [deste](http://backbonejs.org/) link. \r\n\r\nO Backbone possui apenas uma dependência o [Underscore.js](http://documentcloud.github.com/underscore/). O underscode.js dá ao backbone um poderoso suporte a manipulação de arrays, bindings de eventos, suporte a processamento de templates entre outros. O Backbone trabalha bem em conjunto com frameworks de manipulação de DOM como [jQuery](http://jquery.com/), [Zepto](http://zeptojs.com/) e [Ender](http://ender.no.de/) provendo uma propriedade ```Backbone.$``` reservada para o framework dentre estes que estivermos utilizando.\r\n\r\n###O Model (Modelo)\r\n\r\nO Model é um objeto formado por atributos e métodos pertinentes ao modelo de negócio do nosso aplicativo. Vamos ver um código de exemplo:\r\n\r\n<pre><code>var Tarefa = Backbone.Model.extend();\r\n...\r\nvar minhaTarefa = new Tarefa({\r\n\tdescricao: 'Ajustar o código do meu blog para rodar em vários navegadores diferentes', \r\n\testaFeito: false\r\n});</code></pre>\r\n\r\nNo código acima estamos criando um Model chamado Tarefa para um aplicativo de 'lista de tarefas'. Repare que criamos facilmente um model utilizando ``` Backbone.Model.extend() ```.\r\n\r\nPara entender como o Model está situado dentro do backbone e quais suas dependências deixe-me exibir abaixo uma imagem representando os módulos principais do framework que de alguma forma fazem relação com o Model e o próprio Model com suas propriedades e funções principais.\r\n\r\n![Valid XHTML](/img/backbone/backbone_core_model.png)\r\n\r\nÉ um diagrama simples que não segue nenhum padrão especifico mais mesmo assim nos permite entender um pouco os itens principais envolvidos quando estamos lidando com Models.\r\n\r\nVeja que o **Core** do Backbone tem uma dependência direta ao **Underscore.js**. O Underscore tem um papel importante dentro do Backbone por que é através dele que temos os métodos ```_.extend()``` (bastante utilizado no código do Backbone), o método ```_.clone()```, outros que permitem manipulações de Arrays e etc. \r\n\r\nEncontramos também no **Core** todo o gerenciamento de **Eventos** do framework. É apartir deste módulo de eventos que ganhamos os métodos ```on()```, ```off()``` e ```trigger()```. Praticamente tudo o que ocorre no Backbone é propagado como evento e sempre que estamos manipulando o estado de um Model (exceto quando forçamos a interrupção desta propagação de eventos - veremos como isso é possível) eventos são disparados. Ocorrencias inesperadas como erros e exceções tanbém são propagadas por eventos.\r\n\r\nAinda encontramos no **Core** o modulo **Sync**. Este é o responsável por parte do gerenciamento do ciclo de vida do Model incluindo sua persistência. O Backbone vem com uma implementação nativa para fazer a sincronização de Models utilizando **ajax**. Um model possui uma propriedade chamada ```urlRoot``` que ao ser configurada utiliza verbos HTTP seguindo o padrão **REST** para persistir o modelo. Caso por exemplo tenhamos configurado a url como ```'/pessoas'``` sempre que o método ```fetch()``` for invocado o Model tentará montar uma url se utilizando do seu id configurado em uma requisição do tipo **GET**. Seria algo como ```GET '/pessoas/1'``` caso o id configurado fosse 1. Ao chamarmos o metodo ```save()``` caso o model tenha um id configurado ele irá tentar fazer um update deste objeto Model no repositório chamando ```PUT '/pessoas/1'``` e caso não tivessemos nenhum id configurado a url seria ```POST '/pessoas/1'```. Por convenção utilizamos os métodos **GET** para recuperação de dados, **PUT** para update, **POST** para criar um novo e **DELETE** para excluir.\r\n\r\nAinda falando do **Sync** podemos também reescrever este método para que utilize outras fontes de persistência tais como: localStore, sessioStore, MongoDB, CouthDB entre outros. O Model ainda possui propriedades importante como as funções ```get()/set()``` utilizadas para alterar seu estado, ```initialize()```, ```detalts``` para configurar valores iniciais do Model sempre que uma noa instância for criada sem valores passados no construtor. \r\n\r\nTemos também a função ```validate()``` que é uma função muito importante utilizada para garantir que teremos sempre **um objeto com estado válido**. Um objeto com estado inválido não tem utilizade nenhuma e sempre introduzirá bug no nosso aplicativo. É como se tivessemos em uma auto estrata um veículo sem rodas, teriamos um grande problema por que este estádo para o veículo é um estado inválido para o contexto em que ele se encontra (auto estrada). \r\n\r\nPor fim os métodos ```fetch()``` e ```save()``` dos quais já falamos e que iteragem diretamente com o modulo **Sync** pertencente ao Core do Backbone.\r\n\r\n###O Model na pratica\r\n\r\nVimos em um exemplo anterior como criar um Model. Seguindo a apresentação veja que como já foi citado podemos adicionar um método de inicialização no nosso objeto Model inserindo uma função chamada **initialize**. \r\n\r\n<pre><code>var Tarefa = Backbone.Model.extend({\r\n\tinitialize: function(descricao, estaFeito) {\r\n\t\tthis.set({descricao: descricao});\r\n\t\tthis.set({estaFeito: estaFeito});\r\n\t\t/*\r\n\t\tNota: Este trecho támbém poderia ter sido escrito da seguinte maneira:\r\n\t\t...\r\n\t\tthis.set({descricao: descricao, estaFeito: estaFeito});\r\n\t\t*/\r\n\t}\r\n});\r\n\r\nvar umaTarefa = new Tarefa('Refatorar o código da aplicação', true);\r\n\r\nconsole.log(umaTarefa.get('descricao'));\r\n//=> Refatorar o código da aplicação\r\n\r\nconsole.log(umaTarefa.get('estaFeito'));\r\n//=> true</code></pre>\r\n\r\nPoderemos também passar os valores de inicialização dos atributos ao model da seguinte forma:\r\n\r\n<pre><code>...\r\nnew Tarefa({\r\n\tdescricao: 'Refatorar o código da aplicação', \r\n\testaFeito: true\r\n});\r\n...</code></pre>\r\n\r\nEm casos raros podemos também sobrescrever o contrutor do model inserindo uma função chamada **constructor**. Este nos dá um controle bem maior para poder manipular como o nosso modelo será construido.\r\n\r\nO Model armazena os dados em uma propriedade chamada attributes, entretanto por convenção utilizamos os métodos ```get()``` e ```set()``` para alterar seus dados. Se quisermos um json com os dados do model utilizamos o método ```toJSON()```. Aqui cabe ressaltar que o método ```set()``` pode ser utilizado de algumas formas diferentes onde podemos de uma só vez alterar uma ou mais propriedades e manipular erros.\r\n\r\nExemplos:\r\n\r\n<pre><code>...\r\nmodel.get(\"nome\");\r\nmodel.set(\"nome\", \"Diullei Gomes\");\r\nmodel.set({nome: \"Diullei Gomes\"});\r\nmodel.set({nome: \"Diullei Gomes\", idade: 29});\r\n// passando um metodo de manipulação ede erros de validação\r\nmodel.set({nome: \"Diullei Gomes\", idade: 29}, { error: function(model, error) { ... } });\r\n// quando passamos esta função o Backbone cancela a propagação do evento de erro\r\n...</code></pre>\r\n\r\n###Eventos\r\n\r\nSempre que um valor for alterado no model um evento **change** será disparado. Um evento especifico por atributo também é disparado seguindo o padrão 'change:[nome do atributo]' como por exemplo 'change:nome'. Caso você queira alterar o model sem que um evento 'chage' seja disparado configure o modelo setando a propriedade silent com o valor true: ```{silent: true}```.\r\n\r\nPara adicionar funções ao model fazemos da mesma forme que fizemos para adicionar a função 'initialize'. Veja um exemplo:\r\n\r\n<pre><code>var Pessoa = Backbone.Model.extend({\r\n\trecuperaNomeCompleto: function(){\r\n\t\treturn this.get('primeiroNome') + ' ' + this.get('segundoNome');\r\n\t}\r\n});\r\n\r\nvar umaPessoa = new Pessoa({primeiroNome: 'Diullei', segundoNome: 'Gomes'});\r\n\r\nconsole.log(umaPessoa.recuperaNomeCompleto());\r\n//=> Diullei Gomes</code></pre>\r\n\r\nUma outra funcionalidade importante do Model como já foi dito é a possibilidade de escrever um validador. Não queremos objetos com estado inválido por motivos que também já foram discutidos. Para isso escreveremos um método validate() para verificar os dados passados para o Model sempre que o método ```set()``` for chamado. Para criar um validador incluimos um método 'validate' no model como segue:\r\n\r\n<pre><code>var Pessoa = Backbone.Model.extend({\r\n\tvalidate: function(attrs){\r\n\t\tif(attrs.idade <= 0) {\r\n\t\t\treturn \"A idade informada está inválida\";\r\n\t\t}\r\n\t}\r\n});\r\n\r\nvar pessoa = new Pessoa();\r\n\r\npessoa.on(\"error\", function(model, error) {\r\n\tconsole.log('A idade informada: ' + model.get('idade') + ' está errada. Erro: ' + error);\r\n});\r\n\r\npessoa.set({idade: -1});\r\n//=> A idade informada: -1 está errada. Erro: A idade informada está inválida</code></pre>\r\n\r\nNeste exemplo utilizamos a função ```on()``` para registrar os eventos de callback. A utilização desta função é simples, passamos como primeiro argumento o nome do evento que queremos manipular e uma função de 'callback' que será chamada sempre que este evento for disparado. Temos ainda a função ```off()``` que utilizamos para remover o método de 'callback' do model e a função ```trigger()``` utilizada para disparar estes eventos. Veja [on()](http://backbonejs.org/#Events-on), [off()](http://backbonejs.org/#Events-off), [trigger()](http://backbonejs.org/#Events-trigger).\r\n\r\nCaso tenhamos utilizado a propriedade ```silent``` com o valor true podemos ainda chamar a função ```isValid()``` para executar a validação e verificar o nosso model.\r\n\r\nO model possui ainda outros métodos e propriedades. Você pode verificar a documentação no [site](http://backbonejs.org/#Model) oficial do Backbone na sessão [Model](http://backbonejs.org/#Model) para saber mais.\r\n\r\nBem, com isso tudo o que vimos até aqui já da pra ter uma boa base de como trabalhar com Models no Backbone. Não fique limitado apenas ao que foi apresentado aqui neste artigo e verifique a documentação do Backbone para saber mais.\r\n\r\nNos próximos artigos seguiremos com a continuação desta matéria.\r\n\r\nAbraços!\r\n\n","ref":"backbone_model_part1.post.mkdown"}