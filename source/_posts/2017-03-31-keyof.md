---
title: Operador keyof
date: 2017-03-31 08:32:56
category: [TypeScript, TypeScript v2.1]
tags : [TypeScript, JavaScript]
---

Por ser uma linguagem dinâmica, o JavaScript algumas vezes torna difícil a representação de algumas operações em um sistema tipado. Por exemplo, vejamos a seguinte função:

```javascript
function prop(obj, propertyName) {
    return obj[propertyName];
}
```

Essa função aceita um objeto e um nome de propriedade e retorna o valor correspondente desta propriedade. É importante observar que diferentes propriedades em um objeto possuem diferentes tipos. Com isso em mente, como podemos definir o tipo de retorno desta função?

Vamos a uma primeira tentativa:

```typescript
function prop(obj: {}, propertyName: string) {
    return obj[propertyName];
}
```

Adicionamos 2 anotações `obj: {}, propertyName: string`. Com isso estamos dizendo que `obj` precisa ser um objeto e que `propertyName` precisa ser do tipo string. 

Agora como definir o tipo de retorno desta função?

Vamos a um exemplo prático:

```typescript
function prop(obj: {}, propertyName: string) {
    return obj[propertyName];
}

const myObj = {
    strProp: 'str value',
    boolProp: true,
    numberProp: 100
}

const val1 = prop(myObj, 'strProp'); // tipo de retorno 'any'
const val2 = prop(myObj, 'boolProp'); // tipo de retorno 'any'
const val3 = prop(myObj, 'numberProp'); // tipo de retorno 'any'

const val4 = prop(myObj, 'xyz'); // irá falhar em tempo de execução. 
                                 // xyz não é uma propriedade válida neste objeto
```

Para qualquer propriedade existente que pasemos o retorno será inferido como sendo do tipo `any`. Para o caso de passar uma propriedade inexistente teremos um erro em tempo de execução.

Isso ocorre por que neste caso o compilador do TypeScript não consegue prever de antemão quais possíveis objetos serão passados como argumento para `prop(...)` e com isso não é possível inferir o tipo de retorno.

Para fazer com que o compilador reconheça o tipo de `obj` poderíamos ajustar o código da seguinte forma:

```typescript
function prop<T>(obj: T, propertyName: string) {
    return obj[propertyName];
}
```

Note que estamos utilizando um tipo genérico que será inferido no momento em que um objeto for passado em `obj`. Mesmo com esse ajuste, seguimos não alcançando o resultado esperado. Embora agora o compilador entenda o tipo de `obj` ele continua não sabendo se `propertyName` realmente existe em `obj` e, caso exista, qual o seu tipo.

Ok, vamos supor agora em um outro exemplo que sabemos de antemão o tipo exato que será passado para a função `prop(...)`. Suponha que tenhamos uma interface com a seguinte estrutura:

```typescript
interface MyInterface {
    id: number;
    text: string;
    due: Date;
}
```

> Para entender melhor o próximo exemplo de código precisamos relembrar outras duas funcionalidades importantes:
* **Union types** - Permite informar se um objeto pode ser um ou mais tipos diferentes. [Veja mais](/2016/07/13/union-types/).
* **String literal** - Permite definir quais valores um objeto do tipo string pode assumir. [Veja mais](https://github.com/Microsoft/TypeScript/pull/5185).

Vamos reescrever a função da seguinte forma:

```javascript
function prop(obj: MyInterface, propertyName: "id" | "text" | "due") {
    return obj[propertyName];
}
```

Vejamos o que temos até agora. Com essa mudança tentarmos passar uma propriedade que não existe na interface `MyInterface`, ou seja, que não esteja no tipo `"id" | "text" | "due"`, teremos um erro em tempo de compilação.

```typescript
const val4 = prop(myObj, 'xyz'); // erro! 'xyz' não pertende ao tipo "id" | "text" | "due"
```

Isso é bom, resolve parte do problema, mas também nos gera um novo problema. Agora estamos protegendo o valor de `propertyName` definindo o que realmente pode ser passado mas continuamos não tendo como prever o tipo de `obj` e as possíveis propriedades de `obj` em `propertyName`. Nessa função precisa ser genérica, ou seja, funcionar em todos os casos e não somente para o tipo `MyInterface`.

## Solução

Para resolver este tipo de problema foi acrescentado na versão 2.1 do TypeScript o operador `keyof`. O objetivo deste operador é retornar um "union type" de "string literals" representando o nome de cada propriedade do tipo em que estamos aplicando o `keyof`. Confuso não? 

Vamos a um exemplo para entender melhor. Utilizando a mesma interface do exemplo anterior, podemos utilizar o operador `keyof` para retornar um tipo que represente um "union type" de "string literals" com a combinação dos nomes das propriedades de `MyInterface`:

```typescript
type MyInterfaceKeys = keyof MyInterface;  // "id" | "text" | "due"
```

Isso equivale ao mesmo que escrever:

```typescript
type MyInterfaceKeys = "id" | "text" | "due";
```

Mas em alguns casos precisamos que isso seja feito de forma dinâmica sendo recuperado direto de uma dada interface e por isso nesses casos utilizaremos o `keyof`.

Com base no que acabou de ser apresentado, vamos alterar a função `prop(...)` da seguinte forma:

```typescript
function prop<T, K extends (keyof T)>(obj: T, propertyName: K) {
    return obj[propertyName];
}
```

OK, vamos entender as modificações parte a parte:

* Como demonstrado em um exemplo anterior, estamos utilizando um tipo genérico (`T`) para inferir o tipo de `obj` em tempo de compilação.
* Baseado também em exemplos anteriores, estamos utilizando `keyof T` para recuperar um tipo que represente os possíveis nomes de propriedades de `T` (repare que estamos colocando `keyof` entre parêntesis no exemplo só pra facilitar a leitura, no entanto esses parêntesis não são necessários).
* Estamos definindo um outro tipo genérico `K` para extender o tipo gerado por `keyof T`.

Com base nessas informações, agora o compilador consegue inferir que o retorno de `prop(...)` é `T[K]`, e outras palavras, é o tipo resultante da aplicação da propriedade `K` no objeto `T`, e com isso agora temos o retorno da função inferido da forma correta correspondente ao tipo da propriedade solicitada.

```typescript
function prop<T, K extends (keyof T)>(obj: T, propertyName: K) {
    return obj[propertyName];
}

const myObj = {
    strProp: 'str value',
    boolProp: true,
    numberProp: 100
}

const val1 = prop(myObj, 'strProp'); // retorna 'string'
const val2 = prop(myObj, 'boolProp'); // retorna 'boolean'
const val3 = prop(myObj, 'numberProp'); // retorna 'number'

const val4 = prop(myObj, 'xyz'); // irá falhar em tempo de compilação. 
                                 // Argument of type '"xyz"' is not assignable to 
                                 // parameter of type '"strProp" | "boolProp" | "numberProp"'.
```

Excelente não? Isso nos ajuda a prevenir uma série de erros. Esta é só uma das formas de aplcação deste operador. Um bom exemplo pode ser encontrado no arquivo `lib.es2017.object.d.ts` que é instalado junto com o compilador do TypeScript:

```typescript
interface ObjectConstructor {
    // ...
    entries<T extends { [key: string]: any }, K extends keyof T>(o: T): [keyof T, T[K]][];
    // ...
}
```

Essa interface é utilizada para definir o tipo da função [`Object.entries()`](https://developer.mozilla.org/pt-BR/docs/Web/JavaScript/Reference/Global_Objects/Object/entries), onde o retorno é um array com de pares de valores contendo `[propertyName, value]` para um dado objeto.

> Reference: TS v2.1 [https://github.com/Microsoft/TypeScript/pull/11929](https://github.com/Microsoft/TypeScript/pull/11929)
