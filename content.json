{"meta":{"title":"Diullei","subtitle":null,"description":null,"author":"Diullei Gomes","url":"http://diullei.com"},"pages":[{"title":"Who am I?","date":"2017-03-15T21:58:54.000Z","updated":"2018-01-27T19:37:41.228Z","comments":true,"path":"about/index.html","permalink":"http://diullei.com/about/index.html","excerpt":"","text":"It’s not hard to find me on Google, Doubt? My name is Diullei, I’m from Brazil and I’m a Software Developer. I like to say that “I do what I love and I love what I do” :) Currently I live in Oslo - Norway and I work as a full-stack Developer at Resoptima. Usually I like to play with C#, F#, JavaScript, AngularJS, React, TypeScript, Go, Python, SQL, Asp.NET, rubik’s cube, etc, etc … I like to get involved with developer communities and open-source projects. I had the incredible opportunity to contribute to the TypeScript community by creating the DefinitelyTyped organization along with Boris Yankov. I’m also author of TSD - TypeScript package Manager. Talk to me!Would you like to contact me? You can send an email to diullei[at]gmail.com. You can also contact me on twitter (@diullei)."},{"title":"Experiência","date":"2017-03-17T17:23:00.000Z","updated":"2018-01-27T19:37:41.232Z","comments":true,"path":"experiencia/index.html","permalink":"http://diullei.com/experiencia/index.html","excerpt":"","text":"Atualmente sou Fullstack Developer, ou seja, posso atuar tanto no back-end(o lado dos servidores) quanto no front-end(o lado dos clientes, os browsers). Tenho bastante experiência em desenvolvimento de sistemas corporativos. Estou sempre buscando adquirir boas praticas de desenvolvimento. Temas como Arquitetura de Software, Refatoração, Princípios SOLID, Integração Contínua, Versionamento de Código, Automação de tarefas e mais alguns outros estão sempre na minha agenda de trabalho. Sempre que posso busco participar de comunidades por que entendo que ao compartilhar conhecimento estou ajudando outras pessoas a crescer e ao mesmo tempo eu também cresço e aprendo com elas. Formação Engenharia da Computação - Superior UNIG – UNIVERSIDADE NOVA IGUAÇU - RJ Técnico em Processamento de Dados - 2º Grau FAETEC - ESCOLA TÉCNICA ESTADUAL - RJ Técnico em Elétrica - FAETEC/ETEFEV - RJ Linguagens de interesse JavaScript e TypeScript C# Python Clojure Projetos - Open Source DefinitelyTyped Org - Esta organização foi criada com o objetivo de centralizar vários projetos relacionados ao repositório DefinitelyTyped, incluindo o prório DefinitelyTyped. TSD - O TSD é um gerenciador de dependências para buscar e instalar arquivos de definição diretamente do repositório DefinitelyTyped. Trata-se de uma ferramenta de linha de comando similar ao npm ou bower. Ver mais. DefinitelyTyped - O DefintelyTyped é um repositório no Github onde desenvolvedores do mundo inteiro compartilham e ajudam a manter a maior base de arquivos de definição de tipos (TypeScript typings) para as mais diversas bibliotecas javascript. Esse material serve de apoio para inúmeros desenvolvedores no mundo inteiro e podemos dizer que é praticamente impossível desenvolver algum projeto em TypeScript sem a utilização desses arquivos. Ver mais."},{"title":"Projetos","date":"2017-03-17T17:23:20.000Z","updated":"2018-01-27T19:37:41.232Z","comments":true,"path":"projects/index.html","permalink":"http://diullei.com/projects/index.html","excerpt":"","text":"Seguem os projetos Open Source mais relevantes dos quais eu participei: DefinitelyTyped Org - Esta organização foi criada com o objetivo de centralizar vários projetos relacionados ao repositório DefinitelyTyped, incluindo o prório DefinitelyTyped. TSD - O TSD é um gerenciador de dependências para buscar e instalar arquivos de definição diretamente do repositório DefinitelyTyped. Trata-se de uma ferramenta de linha de comando similar ao npm ou bower. Ver mais. DefinitelyTyped - O DefintelyTyped é um repositório no Github onde desenvolvedores do mundo inteiro compartilham e ajudam a manter a maior base de arquivos de definição de tipos (TypeScript typings) para as mais diversas bibliotecas javascript. Esse material serve de apoio para inúmeros desenvolvedores no mundo inteiro e podemos dizer que é praticamente impossível desenvolver algum projeto em TypeScript sem a utilização desses arquivos. Ver mais."},{"title":"DefinitelyTyped","date":"2017-03-23T18:58:52.000Z","updated":"2018-01-27T19:37:41.232Z","comments":true,"path":"definitelyTyped/index.html","permalink":"http://diullei.com/definitelyTyped/index.html","excerpt":"","text":"The repository for high quality TypeScript type definitions Website Organização Repositório http://definitelytyped.org DefinitelyTyped DefinitelyTyped O DefintelyTyped é um repositório no Github onde desenvolvedores do mundo inteiro compartilham e ajudam a manter a maior base de arquivos de definição de tipos (TypeScript typings) para as mais diversas bibliotecas javascript. Esse material serve de apoio para inúmeros desenvolvedores no mundo inteiro e podemos dizer que é praticamente impossível desenvolver algum projeto em TypeScript sem a utilização desses arquivos. Status atual Stars JavaScript Libraries Contributors ~10.105 ~2.990 ~3.515 HistóriaEste repositório é tão antigo quanto a propria linguagem que ele representa. No meado de 2012, quanto o mundo começou a ouvir sobre a nova linguagem da Microsoft não era muito fácil encontrar os famosos typings. A própria Microsoft havia liberado alguns (para o NodeJS e jQuery no que eu me lembro) e alguns outros desenvolvedores isolados estavam escrevendo suas próprias tipagens. Nesse período eu tive a ideia de montar um repositório no Github para agrupar o máximo de tipagens possíveis e ao mesmo tempo comecei a desenvolver o TSD. Acompanhando o fórum do TypeScript no antigo CodePlex eu fiquei sabendo de um outro desenvolvedor (Boris Yankov) que estava desenvolvedo um repositório similar o DefinitelyTyped. Como eu já estava trabalhando no TSD eu resolvi submeter as tipagens que eu estava escrevendo para o DefinitelyTyped e assim eu fui agregado como colaborador passando a apoiar na manutenção deste repositório. Não demorou muito e esse projeto começou a ficar bastante conhecido. Muito desenvolvedores começaram a nos apoiar nos enviando suas tipagens e nos ajudando a manter as que possuíamos. Com o crescimento do repositório fomos aumentando o time e criando outros projetos ao redor do DefinitelyTyped. Com o objetivo de centralizar os projetos e ao mesmo facilitar a gestão de toda a equipe, em um concenso comum, eu criei a organização de mesmo nome: DefinitelyTyped no Github. EquipeO projeto cresceu bastante. Temos atualmente na organização um time com 36 pessoas, incluindo 21 desenvolvedores do próprio time do TypeScript. A maior atividade (também o maior desafio) neste repositório se resume a revisão e aceitação/integração das contribuições. O legal foi que o próprio time do TypeScript abraçou o projeto e hoje tem nos ajudado a manter e a evoluir este repositório em paralelo com a própria linguagem. O DefinitelyTyped pode ser considerado hoje como um projeto vital no ciclo de desenvolvimento de qualquer projeto TypeScript. O interessante é que mesmo desenvolvedores JavaScript, utilizando a IDE correta, podem se beneficiar deste projeto ganhando toda uma gama de ferramentas de apoio como auto-complete, validação de tipos entre outros. EcosistemaAlguns projetos existem em função do DefinitelyTyped. Segue abaixo uma relação dos principais: TSD - Um gerenciador de denpendêcias que permite o download de tipagens diretamente do repositório DefinitelyTyped. typings - Sucessor do TSD. Ferramenta para gerenciamento de dependencias que permite o download de tipagens diretamente do repositório DefinitelyTyped. NugetAutomation - Este projeto foi construido par enviar para o Nuget todas as atualizações de tipagens enviadas para o DefinitelyTyped. Build tester - Projeto criado para ajudar na automatização de testes para contribuições recebidas no repositório. Review bot - Ferramenta de revisão. Tem com função principal notificar os autores das tipagens sempre que uma contribuição é submetida. Badges - Badges para ser colocado em projetos que possuem tipagens no DefinitelyTyped. @types - Com o objetivo de tornar o npm o canal principal de aquisição dos typings, o time da Microsoft criou o @types no npm. ReconhecimentoEstamos sempre sendo citados em fóruns, blogs e conferências ao redor do mundo. Segue abaixo alguns recortes notótios: Build 2016What’s New in TypeScript? - by Anders Hejlsberghttps://channel9.msdn.com/events/Build/2016/B881 Build 2014Building a Large Scale JavaScript Application in TypeScript - by Erich Gammahttps://channel9.msdn.com/Events/Build/2014/3-583 SomasegarVP corporativo da divisão de desenvolvedores da Microsoft em 2014 “… Mas o que realmente se destacou para mim foi quando vimos o repositório do DefinitelyTyped sendo lançado pouco tempo depois que lançamos o TypeScript. Esta era uma comunidade de código aberto criada contendo uma coleção de bibliotecas TypeScript, o que torna ainda mais valioso nosso produto e o aproxima a um conjunto mais amplo de desenvolvedores …” Acesse aqui para ver a entrevista de Somasegar na integra. Meus posts relacionados DefinitelyTyped + TypeScript team = TS FTW TypeScript e o futuro dos arquivos de declaração"},{"title":"TSD","date":"2017-03-24T18:24:54.000Z","updated":"2018-01-27T19:37:41.232Z","comments":true,"path":"tsd/index.html","permalink":"http://diullei.com/tsd/index.html","excerpt":"","text":"TSD is a package manager to search and install TypeScript definition files directly from the community driven DefinitelyTyped repository. Website Organização Repositório http://tsdpm.org DefinitelyTyped DefinitelyTyped O TSD é um gerenciador de dependências para buscar e instalar arquivos de definição diretamente do repositório DefinitelyTyped. Trata-se de uma ferramenta de linha de comando similar ao npm ou bower. Não posso deixar de citar que tive um apoio muito importante neste projeto. “Bart van der Schoor” é um excelente programador e foi um grande contribuidor ( atualmente se voltou para o lado negro da força e foi trabalhar com python :P ). Status atual Stars Downloads Contributors ~1.123 ~1.575.305 ~29 HistóriaLogo após o lançamento do TypeScript eu tive a ideia de criar um gerenciador de dependências que me permitisse buscar e instalar as famosas “tipagens” do TypeScript. Com isso eu criei o TSD. Este projeto teve sua importância e durante alguns anos ele foi muito utilizado por muitos desenvolvedores ao retor no mundo. ReconhecimentoFoi muito legal ver que logo no início apos liberar o TSD no npm eu tive um retorno positivo de vários membros da comunidade. Desde então o TSD passou a ser frequente envários posts, conferencias e fóruns sobre TypeScript. Jonathan Turner - Co-designer of the TypeScript language @Diullei Just saw your tsd tool. Very cool!&mdash; Jonathan Turner (@jntrnr) October 20, 2012 Build 2014Building a Large Scale JavaScript Application in TypeScript - by Erich Gammahttps://channel9.msdn.com/Events/Build/2014/3-583"}],"posts":[{"title":"Operador keyof","slug":"keyof","date":"2017-03-31T06:32:56.000Z","updated":"2019-01-07T23:15:42.331Z","comments":true,"path":"2017/03/31/keyof/","link":"","permalink":"http://diullei.com/2017/03/31/keyof/","excerpt":"Por ser uma linguagem dinâmica, o JavaScript algumas vezes torna difícil a representação de algumas operações em um sistema tipado. Por exemplo, vejamos a seguinte função: 123function prop(obj, propertyName) &#123; return obj[propertyName];&#125; Essa função aceita um objeto e um nome de propriedade e retorna o valor correspondente desta propriedade. É importante observar que diferentes propriedades em um objeto possuem diferentes tipos. Com isso em mente, como podemos definir o tipo de retorno desta função? Vamos a uma primeira tentativa: 123function prop(obj: &#123;&#125;, propertyName: string) &#123; return obj[propertyName];&#125; Adicionamos 2 anotações obj: {}, propertyName: string. Com isso estamos dizendo que obj precisa ser um objeto e que propertyName precisa ser do tipo string. Agora como definir o tipo de retorno desta função?","text":"Por ser uma linguagem dinâmica, o JavaScript algumas vezes torna difícil a representação de algumas operações em um sistema tipado. Por exemplo, vejamos a seguinte função: 123function prop(obj, propertyName) &#123; return obj[propertyName];&#125; Essa função aceita um objeto e um nome de propriedade e retorna o valor correspondente desta propriedade. É importante observar que diferentes propriedades em um objeto possuem diferentes tipos. Com isso em mente, como podemos definir o tipo de retorno desta função? Vamos a uma primeira tentativa: 123function prop(obj: &#123;&#125;, propertyName: string) &#123; return obj[propertyName];&#125; Adicionamos 2 anotações obj: {}, propertyName: string. Com isso estamos dizendo que obj precisa ser um objeto e que propertyName precisa ser do tipo string. Agora como definir o tipo de retorno desta função? Vamos a um exemplo prático: 12345678910111213141516function prop(obj: &#123;&#125;, propertyName: string) &#123; return obj[propertyName];&#125;const myObj = &#123; strProp: 'str value', boolProp: true, numberProp: 100&#125;const val1 = prop(myObj, 'strProp'); // tipo de retorno 'any'const val2 = prop(myObj, 'boolProp'); // tipo de retorno 'any'const val3 = prop(myObj, 'numberProp'); // tipo de retorno 'any'const val4 = prop(myObj, 'xyz'); // irá falhar em tempo de execução. // xyz não é uma propriedade válida neste objeto Para qualquer propriedade existente que pasemos o retorno será inferido como sendo do tipo any. Para o caso de passar uma propriedade inexistente teremos um erro em tempo de execução. Isso ocorre por que neste caso o compilador do TypeScript não consegue prever de antemão quais possíveis objetos serão passados como argumento para prop(...) e com isso não é possível inferir o tipo de retorno. Para fazer com que o compilador reconheça o tipo de obj poderíamos ajustar o código da seguinte forma: 123function prop&lt;T&gt;(obj: T, propertyName: string) &#123; return obj[propertyName];&#125; Note que estamos utilizando um tipo genérico que será inferido no momento em que um objeto for passado em obj. Mesmo com esse ajuste, seguimos não alcançando o resultado esperado. Embora agora o compilador entenda o tipo de obj ele continua não sabendo se propertyName realmente existe em obj e, caso exista, qual o seu tipo. Ok, vamos supor agora em um outro exemplo que sabemos de antemão o tipo exato que será passado para a função prop(...). Suponha que tenhamos uma interface com a seguinte estrutura: 12345interface MyInterface &#123; id: number; text: string; due: Date;&#125; Para entender melhor o próximo exemplo de código precisamos relembrar outras duas funcionalidades importantes: Union types - Permite informar se um objeto pode ser um ou mais tipos diferentes. Veja mais. String literal - Permite definir quais valores um objeto do tipo string pode assumir. Veja mais. Vamos reescrever a função da seguinte forma: 123function prop(obj: MyInterface, propertyName: \"id\" | \"text\" | \"due\") &#123; return obj[propertyName];&#125; Vejamos o que temos até agora. Com essa mudança tentarmos passar uma propriedade que não existe na interface MyInterface, ou seja, que não esteja no tipo &quot;id&quot; | &quot;text&quot; | &quot;due&quot;, teremos um erro em tempo de compilação. 1const val4 = prop(myObj, 'xyz'); // erro! 'xyz' não pertende ao tipo \"id\" | \"text\" | \"due\" Isso é bom, resolve parte do problema, mas também nos gera um novo problema. Agora estamos protegendo o valor de propertyName definindo o que realmente pode ser passado mas continuamos não tendo como prever o tipo de obj e as possíveis propriedades de obj em propertyName. Nessa função precisa ser genérica, ou seja, funcionar em todos os casos e não somente para o tipo MyInterface. SoluçãoPara resolver este tipo de problema foi acrescentado na versão 2.1 do TypeScript o operador keyof. O objetivo deste operador é retornar um “union type” de “string literals” representando o nome de cada propriedade do tipo em que estamos aplicando o keyof. Confuso não? Vamos a um exemplo para entender melhor. Utilizando a mesma interface do exemplo anterior, podemos utilizar o operador keyof para retornar um tipo que represente um “union type” de “string literals” com a combinação dos nomes das propriedades de MyInterface: 1type MyInterfaceKeys = keyof MyInterface; // \"id\" | \"text\" | \"due\" Isso equivale ao mesmo que escrever: 1type MyInterfaceKeys = \"id\" | \"text\" | \"due\"; Mas em alguns casos precisamos que isso seja feito de forma dinâmica sendo recuperado direto de uma dada interface e por isso nesses casos utilizaremos o keyof. Com base no que acabou de ser apresentado, vamos alterar a função prop(...) da seguinte forma: 123function prop&lt;T, K extends (keyof T)&gt;(obj: T, propertyName: K) &#123; return obj[propertyName];&#125; OK, vamos entender as modificações parte a parte: Como demonstrado em um exemplo anterior, estamos utilizando um tipo genérico (T) para inferir o tipo de obj em tempo de compilação. Baseado também em exemplos anteriores, estamos utilizando keyof T para recuperar um tipo que represente os possíveis nomes de propriedades de T (repare que estamos colocando keyof entre parêntesis no exemplo só pra facilitar a leitura, no entanto esses parêntesis não são necessários). Estamos definindo um outro tipo genérico K para extender o tipo gerado por keyof T. Com base nessas informações, agora o compilador consegue inferir que o retorno de prop(...) é T[K], e outras palavras, é o tipo resultante da aplicação da propriedade K no objeto T, e com isso agora temos o retorno da função inferido da forma correta correspondente ao tipo da propriedade solicitada. 1234567891011121314151617function prop&lt;T, K extends (keyof T)&gt;(obj: T, propertyName: K) &#123; return obj[propertyName];&#125;const myObj = &#123; strProp: 'str value', boolProp: true, numberProp: 100&#125;const val1 = prop(myObj, 'strProp'); // retorna 'string'const val2 = prop(myObj, 'boolProp'); // retorna 'boolean'const val3 = prop(myObj, 'numberProp'); // retorna 'number'const val4 = prop(myObj, 'xyz'); // irá falhar em tempo de compilação. // Argument of type '\"xyz\"' is not assignable to // parameter of type '\"strProp\" | \"boolProp\" | \"numberProp\"'. Excelente não? Isso nos ajuda a prevenir uma série de erros. Esta é só uma das formas de aplcação deste operador. Um bom exemplo pode ser encontrado no arquivo lib.es2017.object.d.ts que é instalado junto com o compilador do TypeScript: 12345interface ObjectConstructor &#123; // ... entries&lt;T extends &#123; [key: string]: any &#125;, K extends keyof T&gt;(o: T): [keyof T, T[K]][]; // ...&#125; Essa interface é utilizada para definir o tipo da função Object.entries(), onde o retorno é um array com de pares de valores contendo [propertyName, value] para um dado objeto. Reference: TS v2.1 https://github.com/Microsoft/TypeScript/pull/11929","categories":[{"name":"TypeScript","slug":"TypeScript","permalink":"http://diullei.com/categories/TypeScript/"},{"name":"TypeScript v2.1","slug":"TypeScript/TypeScript-v2-1","permalink":"http://diullei.com/categories/TypeScript/TypeScript-v2-1/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://diullei.com/tags/JavaScript/"},{"name":"TypeScript","slug":"TypeScript","permalink":"http://diullei.com/tags/TypeScript/"}]},{"title":"TypeScript - Decorators","slug":"Decorators-TypeScript","date":"2016-11-20T23:00:00.000Z","updated":"2019-01-07T23:15:42.331Z","comments":true,"path":"2016/11/21/Decorators-TypeScript/","link":"","permalink":"http://diullei.com/2016/11/21/Decorators-TypeScript/","excerpt":"Fala pessoal! Hoje vou falar sobre uma feature muito legal decorators. Utilizamos decorators para inserir metadados e comportamentos em uma declaração de classe, propriedade, métodos ou parâmetro de uma função. Trata-se de uma função com uma assunatura específica (de acordo com o target). Para utilizar um decorator precisamos utilizar o simbolo @ junto com o nome do decorator antes do membro do código que estivermos decorando. Exemplo: 123456class MyClass &#123; @log doSomething(arg) &#123; //... &#125;&#125; NOTA: para utilizar esse recurso é necessário configurar a propriedade experimentalDecorators no arquivo tsconfig.json. Para compilar o arquivo via linha de comando utilize: tsc myFile.ts –target ES5 –emitDecoratorMetadata.","text":"Fala pessoal! Hoje vou falar sobre uma feature muito legal decorators. Utilizamos decorators para inserir metadados e comportamentos em uma declaração de classe, propriedade, métodos ou parâmetro de uma função. Trata-se de uma função com uma assunatura específica (de acordo com o target). Para utilizar um decorator precisamos utilizar o simbolo @ junto com o nome do decorator antes do membro do código que estivermos decorando. Exemplo: 123456class MyClass &#123; @log doSomething(arg) &#123; //... &#125;&#125; NOTA: para utilizar esse recurso é necessário configurar a propriedade experimentalDecorators no arquivo tsconfig.json. Para compilar o arquivo via linha de comando utilize: tsc myFile.ts –target ES5 –emitDecoratorMetadata. Pontos importantes Os decorators são sempre chamados quando uma classe é declarada e não quando um objeto é instanciado. Multiplos decorators podem ser declarados para um mesmo target. não é permitida a utilização de decorators em construtores. Os decorators podem ser do tipo: ClassDecorator, PropertyDecorator, MethodDecorator ou ParameterDecorator. Decorators em MétodosPara definir um decorator para um méroto precisamos criar uma função com os seguintes parâmetros: target - Protótipo da classe que possui o método. propertyKey - Nome do método em que estamos aplicando o decorator. Pode ser um string ou um Symbol descriptor - Uma instância da insterface TypedPropertyDescriptor No primeiro exemplo eu utilizei um decorator chamado @log. Vamos ver uma possível implementação deste decorator: 12345678910111213function log(target: Object, propertyKey: string, descriptor: TypedPropertyDescriptor&lt;any&gt;) &#123; let originalMethod = descriptor.value; // salvando uma referência para o método original // NOTE: não use arrou fynction. Utilize uma declaração normal de função para que o contexto `this` seja interpretado corretamente. descriptor.value = function(...args: any[]) &#123; console.log(\"Argumentos da chamada: \" + JSON.stringify(args)); let result = originalMethod.apply(this, args); // Executa a função e armazena o resultado console.log(\"Valor de retorno: \" + result); return result; // retorna o resultado &#125;; return descriptor;&#125; Chamando a função: 12345678910class MyClass &#123; @log doSomething(arg) &#123; return \"Message -- \" + arg; &#125;&#125;new MyClass().doSomething(\"test\");// =&gt; Argumentos da chamada: [\"test\"]// =&gt; Valor de retorno: Message -- test Agora que vimos como uma declaração simples de decorator funciona vamos entender como declarar decorators que esperam parâmetros. Para isso precisamos declarar uma função com a assinatura de parâmetros desejado e retornar uma outra função com a mesma assinatura do exemplo anterior. Veja o seguinte código: 1234567891011121314151617function log(showArgs: boolean) &#123; return function(target: Object, propertyKey: string, descriptor: TypedPropertyDescriptor&lt;any&gt;) &#123; let originalMethod = descriptor.value; // salvando uma referência para o método original // NOTE: não use arrou fynction. Utilize uma declaração normal de função para que o contexto `this` seja interpretado corretamente. descriptor.value = function(...args: any[]) &#123; if (showArgs) &#123; console.log(\"Argumentos da chamada: \" + JSON.stringify(args)); &#125; let result = originalMethod.apply(this, args); // Executa a função e armazena o resultado console.log(\"Valor de retorno: \" + result); return result; // retorna o resultado &#125;; return descriptor; &#125;&#125; Mais uma vez vamos chamar a função: 123456789class MyClass &#123; @log(false) doSomething(arg) &#123; return \"Message -- \" + arg; &#125;&#125;new MyClass().doSomething(\"test\");// =&gt; Valor de retorno: Message -- test NOTA: sempre que utilizarmos uma decorator em uma função estática o target será a propria função ou invés do protótipo da classe. Decorators em ClassesA assinatura da função que define um decorator para uma classe possui apenas o parâmetro target. Veja o seguinte exemplo: 1234567891011121314const __myClassDecoratorMetaData: any = &#123;&#125;;function MyClassDecorator(value: string) &#123; return function (target: Function) &#123; __myClassDecoratorMetaData[target] = value; &#125;&#125;@MyClassDecorator(“my metadata”)class MyClass &#123; &#125;var myClass = new MyClass();let value: string = __myClassDecoratorMetaData[myClass.constructor];console.log(value); //=&gt; my metadata Existe ainda a possibilidade de adicionar decorators em propriedades e argumentos de função. Tentarei cobrir estas outras duas possibilidades em outro artigo. Até a próxima!","categories":[{"name":"TypeScript","slug":"TypeScript","permalink":"http://diullei.com/categories/TypeScript/"},{"name":"TypeScript v1.5","slug":"TypeScript/TypeScript-v1-5","permalink":"http://diullei.com/categories/TypeScript/TypeScript-v1-5/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://diullei.com/tags/JavaScript/"},{"name":"TypeScript","slug":"TypeScript","permalink":"http://diullei.com/tags/TypeScript/"}]},{"title":"jQuery - 10 dicas de performance","slug":"jQuery-10-dicas-de-performance","date":"2016-10-31T23:00:00.000Z","updated":"2019-01-07T23:15:42.335Z","comments":true,"path":"2016/11/01/jQuery-10-dicas-de-performance/","link":"","permalink":"http://diullei.com/2016/11/01/jQuery-10-dicas-de-performance/","excerpt":"Os anos se passaram e o jQuery continua relevante em pleno 2016. A facilidade de manipulação e a infinidade de artigos na internet ajuda a reforçar a utilização do jQuery e a manter essa biblioteca viva. De fato, poucos anos atrás, escrever codigo compatível com diferentes versões de navegadores seria um trabalho muito árduo se não fosse pelo nosso amigo jQuery. O grande problema com o jQuery é que muitos desenvolvedores ignoram as boas práticas e escrevem codigo muito pobres em performance (isso sem falar sobre design de código). Por que performance é importante?Vou expor duas boas razões: Uma boa performance pode trazer uma boa experiência de uso. Nem sempre seus visitanes vão lhe dizer que seu site está lento, eles simplesmente não vão voltar a acessar o site. O Google leva a performance em consideração para a classificação do seu site no PageRank. Então, vamos aos pontos…","text":"Os anos se passaram e o jQuery continua relevante em pleno 2016. A facilidade de manipulação e a infinidade de artigos na internet ajuda a reforçar a utilização do jQuery e a manter essa biblioteca viva. De fato, poucos anos atrás, escrever codigo compatível com diferentes versões de navegadores seria um trabalho muito árduo se não fosse pelo nosso amigo jQuery. O grande problema com o jQuery é que muitos desenvolvedores ignoram as boas práticas e escrevem codigo muito pobres em performance (isso sem falar sobre design de código). Por que performance é importante?Vou expor duas boas razões: Uma boa performance pode trazer uma boa experiência de uso. Nem sempre seus visitanes vão lhe dizer que seu site está lento, eles simplesmente não vão voltar a acessar o site. O Google leva a performance em consideração para a classificação do seu site no PageRank. Então, vamos aos pontos… 1. Use a versão mais atual do jQuery sempre que possívelAs novas versões sempre trazem melhorias de performance e atualizações de segurança. 2. Utilize os seletores da forma corretaCada seletor possui uma performance diferente. Organizando do mais rápido para o mais lento temos: Seleção por ID - $(&#39;#element-id&#39;) Seleção por Elemento - $(&#39;form&#39;) Seleção por Classe - $(&#39;.some-class&#39;) Seleção por Pseudo Atributo - $(&#39;[data-attr]&#39;), $(&#39;:hidden&#39;) 3. O algoritmo de seleção do jQuery funciona da esquerda para a direitaIsso significa que o lado direto da query de busca precisa ser o mais específico possivel. Neste caso, queries muito longas acabam não fazendo muito sentido e podem ser evitadas. Exemplo: Ruim $(&apos;div.page div.block .element&apos;) Bom $(&apos;.page div.element&apos;) Sempre que possível utilize tag + class 4. Quebre sua query em blocos sempre que possívelSeguindo o conceito do item (3) considere os seguintes códigos: Ruim $(&apos;#container .element&apos;) Bom $(&apos;#container&apos;).find(&apos;.element&apos;) Lembre-se que a busca é sempre feita da direita para a esquerda e por isso, no primeiro exemplo o jQuery irá primeiro buscar por todos os elementos com a classe element e depois filtrar todos os elementos que contenham o id container. Uma outra sintaxe similar ao método find(...) é: $(&apos;.element&apos;, &apos;#container&apos;) 5. Faça sempre um cache dos seus seletoresEste item é muito simular ao anterior. Os exemplos de código abaixo falam por sí só: Ruim var block = $(&apos;.block&apos;); var elements = $(&apos;.block&apos;).find(&apos;.element&apos;); var title = $(&apos;.block&apos;).data(&apos;title&apos;); Bom var block = $(&apos;.block&apos;); var elements = block.find(&apos;.element&apos;); var title = block.data(&apos;title&apos;); 6. Evite a manipulação pesada do DOMVocê pode se surpreender com a quantidade de elementos que é possível manipular utilizando JavaScript. No entanto, se estes elementos estiverem ligados ao DOM essa surpreza será ruim. Manipular elementos no DOM é uma operação muito lenta e quanto mais elementos você precise manipular, pior será a performance. A melhor forma de fazer isso utilizando jQuery é primiro “desacoplar” esses elementos no DOM, manipular e depois retorná-los ao DOM. Exemplo: var elem = $(&apos;.element&apos;); var parent = elem.parent(); elem.detach(); ... operações muito pesadas, ordenação de tabelas por exemplo ... parent.append(elem); 7. Evite “appends” desnecessáriosAo invés de ficar utilizando o método append(...) pra cada elemento que estiver adicionando, procure sempre montar uma string HTML e utiliar o append(...) de uma só vez. 8. Prefira utilizar data() no lugar de attr()O método attr(...) escreve os atributos direto no DOM, e como falamos no item (6), qualquer manipulação direta do DOM deve ser evitada sempre que possível por questões de performance. NOTA: a utilização de data(...) embora preferível pelas questões citadas, deve ser verificada com cautela. Se voce estiver utilizando uma biblioteca de terceiros que esteja manipulando os atributos direto no DOM você poderá ter problemas. 9. Verifique se o elemento realmente existe antes de usá-lo Ruim $(&apos;.element&apos;).slideDown(); // esse ponto executa uma chamada pesada que efetua vários // cálculos mesmo se o elemento não existir Bom var element = $(&apos;.element&apos;); if (element.length) { element.slideDown(); } Verificar se o elemento existe antes de efetuar algumas operações evita que alguns algoritmos sejam executados desnecessáriamente. 10. Evite a utilização de loops Ruim $(&apos;.element&apos;).each(function() { $(this).something().somethingElse(); }); Bom $(&apos;.element&apos;).something().somethingElse(); A API do jQuery nos permite executar muitas operações em grupo baseado no resultado da query. Utilize as operações em grupo sempre que possível. ConclusãojQuery é sem dúvida uma das bibliotecas javascript mais utilizadas e dificilmente perderá esse ranking. Por isso, vale a pena entender melhor como esta biblioteca funciona para utiliza-la da maneira mais correta possível. Até a próxima!","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://diullei.com/categories/JavaScript/"},{"name":"jQuery","slug":"JavaScript/jQuery","permalink":"http://diullei.com/categories/JavaScript/jQuery/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://diullei.com/tags/JavaScript/"},{"name":"jQuery","slug":"jQuery","permalink":"http://diullei.com/tags/jQuery/"}]},{"title":"Arrays tipados - ES6","slug":"Arrays-tipados-ES6","date":"2016-10-27T22:00:00.000Z","updated":"2019-01-07T23:15:42.331Z","comments":true,"path":"2016/10/28/Arrays-tipados-ES6/","link":"","permalink":"http://diullei.com/2016/10/28/Arrays-tipados-ES6/","excerpt":"Os arrays tipados são parte da especificação do ECMAScript 2015 (também conhecido como ES6). Eles foram projetados para facilitar o trabalho com estruturas de dados binárias. Inicialmente os arrays tipados foram introduzidos pelas APIs WebGL com o objetivo de diminuir a dissonância entre as estruturas de dados padrões do JavaScript e as estruturas de dados do C, linguagem base da API WebGL, e com isso permitir ao JavaScript acessar diretamente a estrutura já alocada em memória. Você pode acessar este link para saber quais browsers já suportam esse recurso: http://caniuse.com/#feat=typedarrays Criando Arrays tipadosAqui não existe nenhum segredo, criamos um array tipado da mesma forma que criarpiamos qualquer instância de objeto. em JavaScript: 123var arr = new Uint16Array(10);arr[0] = 0xFFFF;console.log(arr[0]);","text":"Os arrays tipados são parte da especificação do ECMAScript 2015 (também conhecido como ES6). Eles foram projetados para facilitar o trabalho com estruturas de dados binárias. Inicialmente os arrays tipados foram introduzidos pelas APIs WebGL com o objetivo de diminuir a dissonância entre as estruturas de dados padrões do JavaScript e as estruturas de dados do C, linguagem base da API WebGL, e com isso permitir ao JavaScript acessar diretamente a estrutura já alocada em memória. Você pode acessar este link para saber quais browsers já suportam esse recurso: http://caniuse.com/#feat=typedarrays Criando Arrays tipadosAqui não existe nenhum segredo, criamos um array tipado da mesma forma que criarpiamos qualquer instância de objeto. em JavaScript: 123var arr = new Uint16Array(10);arr[0] = 0xFFFF;console.log(arr[0]); O argumento passado no construtor define o número de elementos que estamos alocando neste array (No exemplo acima estamos alocando 10 elementos do tipo numérico uint16, o que de acordo com a especificação deste tipo de array irá alocar 20 bytes de memória). Veja abaixo uma lista com os tipos de arrays tipados disponíveis: Tipo Tamanho (byte) Tipo correspondente em C Int8Array 1 int8_t Uint8Array 1 uint8_t Uint8ClampedArray 1 uint8_t Int16Array 2 int16_t Uint16Array 2 uint16_t Int32Array 4 int32_t Uint32Array 4 uint32_t Float32Array 4 float Float64Array 8 double ArrayBuffer e DataViewArrayBuffer e DataView são parte da implementação de arrays tipados. Um ArrayBuffer básicamente armazena os dados de um array tipado. Por exemplo: 1var fileArrayBuffer = reader.readAsArrayBuffer(file); Neste código ArrayBuffer ira armazenar todos os bytes do arquivo. Como esse arquivo pode estar em encodes diferentes, precisaremos fazer alguma manipulação para ler seu conteúdo. Por exemplo, se este arquivo for do tipo UTF-8 poderemos associar este ArrayBuffer ao tipo Uint16Array para ler corretamente seu conteúdo. 12var arr = new Uint16Array(fileArrayBuffer);String.fromCharCode(arr[0]); // A Já o DataView é um tipo que nos permite acessar estruturas binrias em memória. Exemplo, se tivermos uma estrutura em C declarada da seguinte forma: 1234struct data &#123; unsigned int id; char[10] username;&#125; Iremos ler esta estrutura em JavaScript com o código: 123var buf = new ArrayBuffer(11);var id = new Uint8Array(buf, 0, 1);var username = new Uint8Array(buf, 1, 10); Note que se trata de uma leitura sequencial da memória onde o primeiro byte contém o valor de id e os outros 10 bytes seguintes o valor de username. Aqui estamos utilizando Uint8Array como DataView. Onde esse recurso ja está sendo utilizado? WebGL - Utiliza typed arrays em buffer, pixels e mapas de testuras Canvas - Canvas utiliza um arrau tipado para armazenar uma imagem. 1var uint8ClampedArray = ctx.getImageData(...).data; WebSockets - Uma vez habilitado permite a transferência de dados utilizando um ArrayBuffer. 1webSocket.binaryType = 'arraybuffer'; Outras APIs - File API, XMLHttpRequest, Fetch API, window.postMessage() entre outros. ConclusãoIremos utilizar os Arrays typados em trechos de código muito específicos onde a performance com a manipulação de estruturas de dados mais complexas for importante, como por exemplo a manipulação de imagens e de som. É isso, até a próxima.","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://diullei.com/categories/JavaScript/"},{"name":"ES6","slug":"JavaScript/ES6","permalink":"http://diullei.com/categories/JavaScript/ES6/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://diullei.com/tags/JavaScript/"},{"name":"ES6","slug":"ES6","permalink":"http://diullei.com/tags/ES6/"}]},{"title":"Definindo o tipo de \"this\" em funções","slug":"Type-of-this-for-functions","date":"2016-10-26T22:00:00.000Z","updated":"2019-01-07T23:15:42.331Z","comments":true,"path":"2016/10/27/Type-of-this-for-functions/","link":"","permalink":"http://diullei.com/2016/10/27/Type-of-this-for-functions/","excerpt":"O TypeScript 2.0 nos permite definir o tipo da referência this dentro de uma função. Como sempre, para entender melhor, vamos aos exemplos: 12345class Test &#123; public doSomething() &#123; let self = this; &#125;&#125; Na função doSomething() a variavel self assume o tipo Test. Até aqui nada novo. Agora vamos a outro exemplo: 123function doSomething() &#123; let self = this;&#125;","text":"O TypeScript 2.0 nos permite definir o tipo da referência this dentro de uma função. Como sempre, para entender melhor, vamos aos exemplos: 12345class Test &#123; public doSomething() &#123; let self = this; &#125;&#125; Na função doSomething() a variavel self assume o tipo Test. Até aqui nada novo. Agora vamos a outro exemplo: 123function doSomething() &#123; let self = this;&#125; Na função doSomething() acima a variável self assume o tipo any. Isso por que se trata de uma função isolada, fora de uma classe. O que acontece é que agora com a nova versão do TypeScript podemos definir o tipo de this para funções isoladas. Vamos tomar como base a função doSomething(). Digamos que queiramos impedir que um desenvolvedor, por engano, tente chamar qualquer método ou atributo de this dentro desta função. Para isso vamos reescrever essa função da seguinte forma: 123function doSomething(this: void) &#123; let self = this;&#125; Agora o tipo de self é void. Como void não poss membros, caso alguem tente chamar qualquer um de seus membros por engano um erro será exibido em tempo de compilação. Utilizamos uma nova notação onde criamos um argumento chamado this e definimos seu tipo. Esse argumento precisa ser sempre o primeiro argumento dentro da função e ele não será repassado para o código final servindo apenas para informar ao compilador o tipo que queremos definir para this. Agora vamos a um exemplo mais prático. Veja a seguinte interface: 123interface UIElement &#123; addClickListener(onclick: (this: void, e: Event) =&gt; void): void;&#125; Note que a função addClickListener(...) espera uma outra função como parâmetro que não utilize this no seu bloco de código. Se temtarmos passar uma função que viole essa definição teremos um erro: 1234567891011121314interface UIElement &#123; addClickListener(onclick: (this: void, e: Event) =&gt; void): void;&#125;var uiElement: UIElement = &lt;any&gt;&#123;&#125;;class Handler &#123; info: string; onClickBad(this: Handler, e: Event) &#123; this.info = \"message\"; &#125;;&#125;let h = new Handler();uiElement.addClickListener(h.onClickBad); // erro! Veja que dentro da função onClickBad() estamos usando this normalmente. Mas se tentarmos passar a função onClickBad como argumento em addClickListener(...)… 1uiElement.addClickListener(h.onClickBad); // erro! …teremos um erro de compilação. NOTA: Para utilizar este recurso precisamos habilitar a chave --noImplicitThis bo arquivo tsconfig.json ou passando diretamente via linha de comando. É isso. Até a próxima. Reference: TS v2.0 issues/3694 e pull/4910","categories":[{"name":"TypeScript","slug":"TypeScript","permalink":"http://diullei.com/categories/TypeScript/"},{"name":"TypeScript v2.0","slug":"TypeScript/TypeScript-v2-0","permalink":"http://diullei.com/categories/TypeScript/TypeScript-v2-0/"}],"tags":[{"name":"TypeScript","slug":"TypeScript","permalink":"http://diullei.com/tags/TypeScript/"}]},{"title":"TypeScript e o tipo \"never\"","slug":"TypeScript-and-the-Never-type","date":"2016-10-25T22:00:00.000Z","updated":"2019-01-07T23:15:42.331Z","comments":true,"path":"2016/10/26/TypeScript-and-the-Never-type/","link":"","permalink":"http://diullei.com/2016/10/26/TypeScript-and-the-Never-type/","excerpt":"Continuando a série de artigos sobre as novidades da versão 2.0 do TypeScript hoje eu vou falar um pouco sobre o tipo never. Como vimos no post sobre união discriminada de tipos e em outro post sobre type guards, o compilador do TypeScript possui um recurso que analiza todas as possíveis rotas de fluxo no código que está sendo compilado com o objetivo de definir da forma mais precisa possível o tipo das variáveis que estão sendo utilizadas (Veja o ultimo post “união discriminada de tipos” para entender um pouco mais). Em um aplicativo, em alguns casos, teremos fluxos no código que nuca serão executados. Por causa disso, para prover uma analize de código mais completa o time do TypeScript inseriu um novo tipo chamado never. Entenda o tipo never com a representação de valores que nunca serão retornados. Encontraremos o tipo never no código de 2 maneiras diferentes. Ele pode ocorrer naturalmente. Por exemplo: 123456let result = (() =&gt; &#123; while (true) &#123; //... &#125;&#125;)();// let result: never","text":"Continuando a série de artigos sobre as novidades da versão 2.0 do TypeScript hoje eu vou falar um pouco sobre o tipo never. Como vimos no post sobre união discriminada de tipos e em outro post sobre type guards, o compilador do TypeScript possui um recurso que analiza todas as possíveis rotas de fluxo no código que está sendo compilado com o objetivo de definir da forma mais precisa possível o tipo das variáveis que estão sendo utilizadas (Veja o ultimo post “união discriminada de tipos” para entender um pouco mais). Em um aplicativo, em alguns casos, teremos fluxos no código que nuca serão executados. Por causa disso, para prover uma analize de código mais completa o time do TypeScript inseriu um novo tipo chamado never. Entenda o tipo never com a representação de valores que nunca serão retornados. Encontraremos o tipo never no código de 2 maneiras diferentes. Ele pode ocorrer naturalmente. Por exemplo: 123456let result = (() =&gt; &#123; while (true) &#123; //... &#125;&#125;)();// let result: never Se observarmos o código da função anônima acima veremos um “loop infinito”, o código fica eternamente executando dentro do bloco while e nunca retorna um valor, ou seja, nunca finaliza. Como o compilador do TypeScript analiza todo código que está sendo escrito, ele entende naturalmente que se trata de um bloco de código que nunca será executado e por isso, no nosso caso, ele define o valor de retorno da função como never. Além de fluxos com “loop infinito” o compilador também irá inferir o tipo never para funções que lançam exceção em seu fluxo principal. Exemplo: 1234567891011function error(message: string): never &#123; throw new Error(message);&#125;// Inferred return type is neverfunction fail() &#123; return error(\"Something failed\");&#125;let result = fail();// let result: never A outra forma de encontrar o tipo never é quando declaramos diretamente este tipo. Exemplo: 123function alwaysNever(): never &#123; throw new Error(\"!\");&#125; Confundindo o tipo “never” com o tipo “void”É muito comum a primeira vista alguem confundir o tipo never com o tipo void, mas se olharmos com mais atenção veremos que são tipos completamente diferentes. Para explicar melhor essa diferença vamos a um caso de uso: Antes de termos o tipo never o código acima (função function alwaysNever() { ... }) seria reconhecido como sendo do tipo void. Algo similar ao código abaixo: 123function alwaysThrows(): void &#123; throw new Error(\"!\");&#125; Como void não é um subtipo, a auusencia do tipo never ocasionava em alguns momentos alguns efeitos colaterais, veja o exemplo abaixo: 123456789function alwaysThrows(): void &#123; throw new Error(\"!\");&#125;function test(a: boolean) &#123; return a ? 123 : alwaysThrows();&#125;let result = test(false); Se verificarmos no código acima, com a ausencia do tipo never a variável result assume o tipo number | void. Isso é um erro por que se verificarmos o retorno da função test(...) tendo o argument a como false teremos na realidade uma exceção e nunca um valor do tipo void. Com isso em mente o tipo da variável result deve ser entendido como number já que temos como unica possibilidadde de retorno é o valor 123. O tipo never nos ajuda a arrumar este efeito colateral pois never é um subtipo de todos os outros tipos conhecidos. Reescrevendo o código acima temos: 123456789function alwaysThrows(): never &#123; throw new Error(\"!\");&#125;function test(a: boolean) &#123; return a ? 123 : alwaysThrows();&#125;let result = test(false); Agora o compilador irá entender corretamente o código e definir o tipo da variavel result como number. É isso, até a próxima! Reference: TS v2.0 pull/8652 e issues/3076","categories":[{"name":"TypeScript","slug":"TypeScript","permalink":"http://diullei.com/categories/TypeScript/"},{"name":"TypeScript v2.0","slug":"TypeScript/TypeScript-v2-0","permalink":"http://diullei.com/categories/TypeScript/TypeScript-v2-0/"}],"tags":[{"name":"TypeScript","slug":"TypeScript","permalink":"http://diullei.com/tags/TypeScript/"}]},{"title":"União discriminada de tipos (Tagged union types)","slug":"Tagged-union-types","date":"2016-10-24T22:00:00.000Z","updated":"2019-01-07T23:15:42.331Z","comments":true,"path":"2016/10/25/Tagged-union-types/","link":"","permalink":"http://diullei.com/2016/10/25/Tagged-union-types/","excerpt":"Hoje vou falar sobre uma feature muito legal que desenbarcou junto com a versão 2.0 to TypeScript, a união discriminada de tipos. Trata-se de uma extensão do recurso type guards que baseia a verificação do tipo dentro de um determinado fluxo do código, tomando como base valor de uma propriedade. A definição pode parecer um pouco confusa, por isso vamos a um exemplo:","text":"Hoje vou falar sobre uma feature muito legal que desenbarcou junto com a versão 2.0 to TypeScript, a união discriminada de tipos. Trata-se de uma extensão do recurso type guards que baseia a verificação do tipo dentro de um determinado fluxo do código, tomando como base valor de uma propriedade. A definição pode parecer um pouco confusa, por isso vamos a um exemplo: 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849interface Square &#123; kind: \"square\"; size: number;&#125;interface Rectangle &#123; kind: \"rectangle\"; width: number; height: number;&#125;interface Circle &#123; kind: \"circle\"; radius: number;&#125;type Shape = Square | Rectangle | Circle;function area(s: Shape) &#123; // Repare que no bloco switch abaixo, o tipo da variável \"s\" é reconhecido pelo // compilador de forma diferente em cada bloco condicional. O compilador define // o tipo correto baseado no valor da propriedade \"kind\" definida nas interfaces // acima como um valor constante. Por esse motivo podemos utilizar as propriedades // específicas de cada interface sem precisar fazer uma conversão (cast). switch (s.kind) &#123; case \"square\": return s.size * s.size; case \"rectangle\": return s.width * s.height; case \"circle\": return Math.PI * s.radius * s.radius; &#125;&#125;// Repare como nas funções abaixo o compilador entende a lógica aplicada nos if's e// interpreta o tipo de \"s\" de acordo com a propriedade \"kind\".function test1(s: Shape) &#123; if (s.kind === \"square\") &#123; s; // Aqui \"s\" é do tipo: \"Square\" &#125; else &#123; s; // Aqui \"s\" é do tipo: \"Rectangle | Circle\" &#125;&#125;function test2(s: Shape) &#123; if (s.kind === \"square\" || s.kind === \"rectangle\") &#123; return; &#125; s; // Aqui \"s\" é do tipo \"Circle\"&#125; Por enquanto esse recurso opera apenas sobre propriedades tipo string. Existe a intenção de, no futuro, adicionar suporte a outros tipo como boolean e number. Esper oque este post tenha sido útil. Até a próxima! Reference: TS v2.0 pull/9163, issues/186 e issues/1003","categories":[{"name":"TypeScript","slug":"TypeScript","permalink":"http://diullei.com/categories/TypeScript/"},{"name":"TypeScript v2.0","slug":"TypeScript/TypeScript-v2-0","permalink":"http://diullei.com/categories/TypeScript/TypeScript-v2-0/"}],"tags":[{"name":"TypeScript","slug":"TypeScript","permalink":"http://diullei.com/tags/TypeScript/"}]},{"title":"TypeScript 2.0","slug":"TypeScript-2","date":"2016-10-23T22:00:00.000Z","updated":"2019-01-07T23:15:42.331Z","comments":true,"path":"2016/10/24/TypeScript-2/","link":"","permalink":"http://diullei.com/2016/10/24/TypeScript-2/","excerpt":"Finalmente consegui voltar a ativa depois de algum tempo sem escrever. Hoje vou falar sobre a ultima versão do TypeScript, a versão 2.0. Essa versão é o resultado de muito trabalho e esforço do time do TypeScript e da comunidade. Para começar a utilizar esta nova versão você pode baixar via npm utilizando o seguinte comando: npm install -g typescript@2.0 Pronto! Agora você já está pronto para começar a explorar as novas features!","text":"Finalmente consegui voltar a ativa depois de algum tempo sem escrever. Hoje vou falar sobre a ultima versão do TypeScript, a versão 2.0. Essa versão é o resultado de muito trabalho e esforço do time do TypeScript e da comunidade. Para começar a utilizar esta nova versão você pode baixar via npm utilizando o seguinte comando: npm install -g typescript@2.0 Pronto! Agora você já está pronto para começar a explorar as novas features! Um pouco de história (Acontecimentos principais) TypeScript 0.8 - Em Outubro de 2012 os desenvolvedores foram surpreendidos com o que muitos chamavam de “O CofeeScript da Microsoft”. O TypeScript veio ao mundo e muitos começaram a entender as inúmeras possibilidades de se ter uma linguagem mundialmente popular como o JavaScript mesclada a um forte sistema de tipos (que na época nem era tão forte assim rs). DefinitelyTyped - Alguns meses depois do lançamento do TypeScript a comunidade começou a se movimentar. Nesta época eu iniciei a construção do TSD com a intenção de aprender mais sobre TypeScript e ao mesmo tempo criar alguma ferramenta que fosse útil não apenas pra mim, mas para outros desenvolvedores. Conversando em fóruns com outros desenvolvedores entusiastas (que eram poucos na época) eu puder conhecer alguns pessoas que hoje são figuras bastante conhecidas entre os desenvolvedores TypeScript e pudemos juntos montar o time DefinitelyTyped. TypeScript 1.0 - Há alguns anos atrás a versão 1.0 do TypeScript foi disponibilizada e com ela os desenvolvedores puderam entender o potencial do trabalho com JavaScript combinado com um forte sistema de tipagem estática. Alertas de erro em tempo de compilação, editores com recursos de navegação e refatoração, entre outras ferramentas trouxeram para os desenvolvedores um enorme ganho de produtividade. TypeScript 1.1 - A versão 1.1 trouxe um compilador totalmente reescrito que passou a executar 4x mais rápido que o anterior. Com este novo compilador ganhamos, além da velocidade de compilação, uma grande flexibilidade ma interação com o código para adição de novas features. Uma outra grande mudança foi a migração do código do TypeScript do Codeplex para o Github. Essa sem dúvidade potêncializou muito a comunicação com a comunidade permitindo uma maior participação e contrinbuição, seja ajudando a especificar novas fetures, submetendo bugs ou programando diretamente no código do compilador. TypeScript 1.4 e 1.5 - Essa versão trouxe um grande suporte a features do ES2015/ES6. Juntamente com isso passamos a ter suporte a modules e decorators, o que permitiu ao time do Angular2 adotar o TypeSCript como linguagem oficial. Uma parceria muito produtiva que trouxe ainda muito mais recursos e feedbacks. TypeScript 1.6 e 1.8 - Com essa versão tivemos muitas melhorias no sistema de tipos do TypeScript. Tivemos a cada release a adição de padrões JavaScript, o que proporcionou um maior suporte a bibliotecas JavaScript existentes. Muitas melhorias no compilador também foram feitas neste período. TypeScript 2.0 - Finalmente! Agora temos um grande suporte a bibliotecas JavaScript, excelentes ferramentas, um poderoso Language Service e muito mais… vamos falar um pouco sobre as principais novidades. Novidades no TypeScript 2.0Eu já tenho falado a um tempo sobre algumas features planejadas para esta versão. Algumas já haviam sido liberadas para teste em versões beta. Vou tentar mais uma vez destacar as principais features que trouzxeram grandes mudanças para a linguagem: Aquisição de definiçoes de tipo (os famosos arquivos .d.ts)Grandes ferramentas desenvolvidas pela comunidade (e eu tive a oportunidade de desenvolver uma delas) como o Typings e o TSD contribuiram bastante para o ecosistema do TypeScript ajudando milhares de desenvlvedores ao redor do munto a obter arquivos de definição para as mais diversas bibliotecas JavaScript, no entanto, existe um gerenciador de download de pacotes que já se popularizou muito entre os desenvolvedores JavaScript e nada melhor do que utilizar este mesmo gerenciador no ciclo de trabalho com TypeScript, o npm. Um esforço do time do TypeScript junto com o time do DefinitelyTyped e outros membros da comunidade trouxe ao TypeScript a capacidade de obter tipagens diretamente do npm. Isso ajuda a simplificar e muito o workflow de senvolvimento, já que, já temos uma infinidade de ferramentas diferentes que precisam ser utilizadas. Nada melhor do que tentar simplificar as coisas. O TSD e o Typings ajudaram bastante no passado, mas agora com o npm, a tendência é que o trabalho se torne mais simples e padronizado. Por exemplo, se você quiser baixar o arquivo de definição do lodash basta utilizar a seguinte linha de comando: npm install –save @types/lodash Neste post você encontra mais detalhes sobre a aquisição de arquivos de definição direto do npm. Tipos não nulosUma das maiores causas de bug em software são falhas relacionadas a tipos nulos. É muito comum um desenvolvedor não verificar se as variáveis e/ou parâmetros estão ou não nulos antes de começar a utilizá-los. Para facilitar nossa vida temos agora a adição deste novo recurso. Em JavaScript além do valor null temos o undefined e estes dois valores se tornam a fonte do mal quando não são bem compreendidos e tratados. Originalmente no TypeScript todos os tipos eram nullables, ou seja, qualquer tupo poderia arssumir um valor nulo. Agora com o novo compilador os valores null e undefined foram separados como tipos diferentes, ou seja, ao utilizar este novo recurso precisamos de forma declarativa definir se uma variável ou argumento terá o valor null ou undefined. Fazemos isso utilizando o recurso union types. Você pode verificar este post para entender mais. Controle de fluxo por analize de tiposEste não é um revcurso novo, foi inserido no TypeScript desde a versão 1.8, no entanto com a versão 2.0 este recurso foi expandido e ganhou muito mais poder, principalmente quando este é combinado com tipos non-nullables. Exemplo: 123456789function f(condition: boolean) &#123; let result: number; if (condition) &#123; result = computeImportantStuff(); &#125; // Ops! 'result' pod nunca ter sido inicializado! return result;&#125; Você pode acessar este post para saber mais. Modificador readonlyAgora podemos definir membros imutaveis em TypeScript de forma muito fácil. Basta declarar as propriedades como readonly. Exemplo: 1234567891011121314class Person &#123; readonly name: string; constructor(name: string) &#123; if (name.length &lt; 1) &#123; throw new Error(\"Empty name!\"); &#125; this.name = name; &#125;&#125;// Erro! 'name' é somente leitura.new Person(\"Daniel\").name = \"Dan\"; Lindo neh? Existem ainda muitos outros recursos que podem ser conferidos aqui. O que esperar do futuro?Muita coisa ainda está por vir. O JavaScript é uma das linguagens mais utilizadas no mundo, difícil um programador web hoje em dia não ter escrito ao menos algumas linhas de código em JavaScript. O TypeScript veio para ficar. Novas features virão, novas ferramentas e editores, e quem irá usufruir de tudo isso somos nós desenvolvedores. Até a próxima!","categories":[{"name":"TypeScript","slug":"TypeScript","permalink":"http://diullei.com/categories/TypeScript/"},{"name":"TypeScript v2.0","slug":"TypeScript/TypeScript-v2-0","permalink":"http://diullei.com/categories/TypeScript/TypeScript-v2-0/"}],"tags":[{"name":"TypeScript","slug":"TypeScript","permalink":"http://diullei.com/tags/TypeScript/"}]},{"title":"ES6 - strings - Novos métodos","slug":"ES6-strings-new-methods","date":"2016-07-24T22:00:00.000Z","updated":"2019-01-07T23:15:42.331Z","comments":true,"path":"2016/07/25/ES6-strings-new-methods/","link":"","permalink":"http://diullei.com/2016/07/25/ES6-strings-new-methods/","excerpt":"O ES6 trouxe várias features legais para manipulação de strings. Hoje quero falar sobre 4 funções: startsWith, endsWith, includes e repeat. Se você já precisou verificar o inicio ou final de um texto para validar se o mesmo inicia com algum padrão pré estabelecido você certamente já precisou escrever algum código utilizando a função indexOf. Exemplo: 1234567891011121314var list = ['iPhone 5', 'Moto X2', 'iPad 2', 'iPhone 6'];var iphones = list.filter(function(x) &#123; // verifica se o texto inicia com \"iPhone\" // esse trecho de código não é nada legível return x.indexOf('iPhone') === 0;&#125;);iphones.forEach(function(x) &#123; console.log(x);&#125;);// =&gt; iPhone 5// =&gt; iPhone 6","text":"O ES6 trouxe várias features legais para manipulação de strings. Hoje quero falar sobre 4 funções: startsWith, endsWith, includes e repeat. Se você já precisou verificar o inicio ou final de um texto para validar se o mesmo inicia com algum padrão pré estabelecido você certamente já precisou escrever algum código utilizando a função indexOf. Exemplo: 1234567891011121314var list = ['iPhone 5', 'Moto X2', 'iPad 2', 'iPhone 6'];var iphones = list.filter(function(x) &#123; // verifica se o texto inicia com \"iPhone\" // esse trecho de código não é nada legível return x.indexOf('iPhone') === 0;&#125;);iphones.forEach(function(x) &#123; console.log(x);&#125;);// =&gt; iPhone 5// =&gt; iPhone 6 Note que foi necessário utilizar a função indexOf. Essa função retorna o número correspondente ao caracter no texto (iniciando com zero) que inicia com o padrão passado como parâmetro. No nosso caso “iPhone”. Caso o padrão não seja encontrado a função retorna o valor -1. O que algumas pessoas fazem é adicionar “na força” um método novo ao objeto string para que o código fique mais legíveil: 123456if (!String.prototype.startsWith) &#123; String.prototype.startsWith = function(searchString, position) &#123; position = position || 0; return this.indexOf(searchString, position) === position; &#125;;&#125; Com isso podemos reescrever o código do nosso primeiro exemplo da seguinte forma: 1234567891011var list = ['iPhone 5', 'Moto X2', 'iPad 2', 'iPhone 6'];var iphones = list.filter(function(x) &#123; return x.startsWith('iPhone');&#125;);iphones.forEach(function(x) &#123; console.log(x);&#125;);// =&gt; iPhone 5// =&gt; iPhone 6 Repare que com a utilizção do método “startsWith” o código ficou mais intuitivo do que o anterior. ES6 - Novas funçõesCom a chegada do ES6 não precisamos mais fazer essas manobras. Segue abaixo a descrição de algumas funções que foram adicionadas ao javascript: startsWith(…)Isso mesmo, a função que acabamos de ver nos exemplos anteriores! 12'hello'.startsWith('hell');//=&gt; true endsWith(…)Similar a função startsWith só que esta verifica se o texto termina com o padrão informado: 12'hello'.endsWith('ello');//=&gt; true includes(…)Utilizamos esta função para identificar se um texto contem um outro texto: 12'hello'.includes('ell');//=&gt; true No caso acima o texto “hello” contem uma ocorrencia do outro texto “ell” repeat(…)Utilizamos o repeat para repetir um texto n vezes: 12'blah '.repeat(3);//=&gt; \"blah blah blah \" Existem ainda outras funções no objeto string. Irei apresenta-las num próximo post. Até a próxima!","categories":[{"name":"TypeScript","slug":"TypeScript","permalink":"http://diullei.com/categories/TypeScript/"},{"name":"ES6","slug":"TypeScript/ES6","permalink":"http://diullei.com/categories/TypeScript/ES6/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://diullei.com/tags/JavaScript/"},{"name":"TypeScript","slug":"TypeScript","permalink":"http://diullei.com/tags/TypeScript/"},{"name":"ES6","slug":"ES6","permalink":"http://diullei.com/tags/ES6/"}]},{"title":"ES6 - Nova sintaxe para criação de objetos","slug":"Object-literal-features","date":"2016-07-17T22:00:00.000Z","updated":"2019-01-07T23:15:42.331Z","comments":true,"path":"2016/07/18/Object-literal-features/","link":"","permalink":"http://diullei.com/2016/07/18/Object-literal-features/","excerpt":"Com o ES6 temos a possibilidade de criar objetos com uma sintaxe bem diferente da que estávamos acostumados até agora. Vamos tomar como exemplo a seguinte declarção: 1234567const firstName = 'Diulle';const secondName = 'Gomes';let obj = &#123; firstName: firstName, secondName: secondName&#125;; Utilizando a nova sintaxe podemos reescrever esse trecho de código da seguinte forma: 1234567const firstName = 'Diulle';const secondName = 'Gomes';let obj = &#123; firstName, secondName&#125;;","text":"Com o ES6 temos a possibilidade de criar objetos com uma sintaxe bem diferente da que estávamos acostumados até agora. Vamos tomar como exemplo a seguinte declarção: 1234567const firstName = 'Diulle';const secondName = 'Gomes';let obj = &#123; firstName: firstName, secondName: secondName&#125;; Utilizando a nova sintaxe podemos reescrever esse trecho de código da seguinte forma: 1234567const firstName = 'Diulle';const secondName = 'Gomes';let obj = &#123; firstName, secondName&#125;; Note que neste caso o nome da variável será considerado também como nome da propriedade do objeto. Existe ainda uma outra forma conhecida como “Computed property key” onde podemos passar o resultado de uma expressão na criação de uma propriedade. Veja o seguinte exemplo: 1234567const firstName = 'firstName';let obj = &#123; [firstName]: 'Diullei', ['secondName']: 'Gomes', ['other' + 'name']: 'Moura'&#125;; Essa mesma sintaxe também pode ser aplicada par a criação de funções. Por exemplo, o seguinte trecho de códiogo: 12345const obj = &#123; myMethod: function(x, y) &#123; //... &#125;&#125;; Pode ser reescrito da seguinte forma: 12345const obj = &#123; myMethod(x, y) &#123; //... &#125;&#125;; Ou assim: 12345const obj = &#123; ['myMethod'](x, y) &#123; //... &#125;&#125;; O objetivo principal dessa nova sintaxe é facilitar a utilização de Symbols como nome de propriedades. Exemplo: 12345678910111213const obj = &#123; * [Symbol.iterator]() &#123; yield 'hello'; yield 'world'; &#125;&#125;;for (const x of obj) &#123; console.log(x);&#125;// Output:// hello// world No código acima estamos criando um objeto com um generator identificado por Symbol.iterator. Veremos mais a fundo a utilização de Symbols em outros artigos. O legal é que o TypeScript já suporta a utilização dessa sintaxe! Por hoje é só. Abraços!","categories":[{"name":"TypeScript","slug":"TypeScript","permalink":"http://diullei.com/categories/TypeScript/"},{"name":"TypeScript v1.4","slug":"TypeScript/TypeScript-v1-4","permalink":"http://diullei.com/categories/TypeScript/TypeScript-v1-4/"},{"name":"ES6","slug":"TypeScript/TypeScript-v1-4/ES6","permalink":"http://diullei.com/categories/TypeScript/TypeScript-v1-4/ES6/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://diullei.com/tags/JavaScript/"},{"name":"TypeScript","slug":"TypeScript","permalink":"http://diullei.com/tags/TypeScript/"},{"name":"ES6","slug":"ES6","permalink":"http://diullei.com/tags/ES6/"}]},{"title":"TypeScript - Type Guards","slug":"TypeScript-Type-Guards","date":"2016-07-15T22:00:00.000Z","updated":"2019-01-07T23:15:42.331Z","comments":true,"path":"2016/07/16/TypeScript-Type-Guards/","link":"","permalink":"http://diullei.com/2016/07/16/TypeScript-Type-Guards/","excerpt":"Hoje vamos falar sobre Type Guards. Trata-se de um recurso do TypeScript que permite, a partir de uma validação de tipo, assumir que uma variável ou argumento declarado com o tipo any ou proveniente de uma uniao de tipos, é de um tipo específico préviamente verificado sem a necessidade de utilizar cast. Um pouco complicado neh? Nada melhor do que um exemplo para entendermos melhor: Código utilizando cast: 123456789function fn(arg: any): any &#123; if (typeof arg === \"string\") &#123; return (&lt;string&gt;arg).charCodeAt(0); &#125; else if (typeof arg === \"number\") &#123; return (&lt;number&gt;arg).toFixed(10); &#125; else &#123; // aqui arg continua sendo entendido como any &#125;&#125;","text":"Hoje vamos falar sobre Type Guards. Trata-se de um recurso do TypeScript que permite, a partir de uma validação de tipo, assumir que uma variável ou argumento declarado com o tipo any ou proveniente de uma uniao de tipos, é de um tipo específico préviamente verificado sem a necessidade de utilizar cast. Um pouco complicado neh? Nada melhor do que um exemplo para entendermos melhor: Código utilizando cast: 123456789function fn(arg: any): any &#123; if (typeof arg === \"string\") &#123; return (&lt;string&gt;arg).charCodeAt(0); &#125; else if (typeof arg === \"number\") &#123; return (&lt;number&gt;arg).toFixed(10); &#125; else &#123; // aqui arg continua sendo entendido como any &#125;&#125; Código utilizando type guards: 123456789function fn(arg: any): any &#123; if (typeof arg === \"string\") &#123; return arg.charCodeAt(0); // arg já é entendido como string aqui &#125; else if (typeof arg === \"number\") &#123; return arg.toFixed(10); // arg já é entendido como number aqui &#125; else &#123; // aqui arg continua sendo entendido como any &#125;&#125; Note que o argumento arg foi declarado como any e dentro do bloco if que verifica se o tipo de arg é string o compilador entende que arg é string e lista no intellisense do editor todos os membros do tipo string. O mesmo acontece para o bloco de if que verifica se o tipo é number. Esse mesmo comportamento ocorre para tipos declarados com o operador de “union types”. 1234567function fn(arg: string | number): any &#123; if (typeof arg === \"string\") &#123; return arg.charCodeAt(0); // arg é entendido como string aqui &#125; else if (typeof arg === \"number\") &#123; return arg.toFixed(10); // arg é entendido como number aqui &#125;&#125; Utilizamos o operador typeof para verificação de tipos primitivos. Caso queiramos utilizar o mesmo recurso para clases pré-definidas utilizamos o operador instanceof: 1234567891011class A &#123; name: string;&#125;function fn(arg: string | A): any &#123; if (typeof arg === \"string\") &#123; return arg.charCodeAt(0); // arg é entendido como string aqui &#125; else if (arg instanceof A) &#123; return arg.name; // arg é entendido como A aqui &#125;&#125; O legal desse recurso é que não precisamos ficar sujando o código fazendo cast. Uma solução muito mais elegante e limpa. Até a próxima! Reference: TS v1.4 https://github.com/Microsoft/TypeScript/pull/824#issuecomment-58273237","categories":[{"name":"TypeScript","slug":"TypeScript","permalink":"http://diullei.com/categories/TypeScript/"},{"name":"TypeScript v1.4","slug":"TypeScript/TypeScript-v1-4","permalink":"http://diullei.com/categories/TypeScript/TypeScript-v1-4/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://diullei.com/tags/JavaScript/"},{"name":"TypeScript","slug":"TypeScript","permalink":"http://diullei.com/tags/TypeScript/"}]},{"title":"TypeScript - Um pouco mais sobre Union types","slug":"TypeScript-um-pouco-mais-sobre-union-types","date":"2016-07-14T22:00:00.000Z","updated":"2019-01-07T23:15:42.331Z","comments":true,"path":"2016/07/15/TypeScript-um-pouco-mais-sobre-union-types/","link":"","permalink":"http://diullei.com/2016/07/15/TypeScript-um-pouco-mais-sobre-union-types/","excerpt":"Esse post é uma continuação do post anterior onde eu falei sobre union types. Meu objetivo aqui é expor algumas propriedades básicas inerentes a declaração dos “union types”. Para ficar fácel de entender vou colocar um exemplo de código para cada propriedade. Vamos lá! Identidade A | A é equivalente a A 123class A &#123; /* ... */ &#125;let a: A | A = new A(); Comutativa A | B é equivalente a B | A 1234567class A &#123; /* ... */ &#125;class B &#123; /* ... */ &#125;let a: A | B;let b: B | A;a = b; OBS: O tipo resultante de A | B será um tipo com todas as propriedades comuns a A e B. Equivalente a uma intercessão entre os tipos.","text":"Esse post é uma continuação do post anterior onde eu falei sobre union types. Meu objetivo aqui é expor algumas propriedades básicas inerentes a declaração dos “union types”. Para ficar fácel de entender vou colocar um exemplo de código para cada propriedade. Vamos lá! Identidade A | A é equivalente a A 123class A &#123; /* ... */ &#125;let a: A | A = new A(); Comutativa A | B é equivalente a B | A 1234567class A &#123; /* ... */ &#125;class B &#123; /* ... */ &#125;let a: A | B;let b: B | A;a = b; OBS: O tipo resultante de A | B será um tipo com todas as propriedades comuns a A e B. Equivalente a uma intercessão entre os tipos. Associativa (A | B) | C é equivalente a A | (B | C) 12345678class A &#123; /* ... */ &#125;class B &#123; /* ... */ &#125;class C &#123; /* ... */ &#125;let a: (A | B) | C;let b: A | (B | C);a = b; O tipo S pode ser associado ao tipo T1 | T2 se S for do tipo T1 ou S for do tipo T2. 1234let x: string | number;x = 'olá'; // OKx = 42; // OKx = &#123; &#125;; // Erro Outros casos notáveisHerança A | B é equivalente a A se B é um subtipo de A 1234567class A &#123; /* ... */ &#125;class B extends A &#123; /* ... */ &#125;let a: A;let b: A | B;a = b; Propriedades O tipo A | B tem uma propriedade P do tipo X | Y se á tiver uma propriedade P do tipo X e B tiver uma propriedade P do tipo Y. Essas propriedades precisam ter o mesmo tipo de acessor, ou seja precisam ser ao mesmo tempo public, private or protected. 12345class A &#123; prop: number; &#125;class B &#123; prop: string; &#125;let x: A | B;let y = x.prop; // o tipo de y é number | string FunçõesA mesma regra aplicada às propriedades exibida no item anterior também se aplica a funções. Em A | B se A e B tiverem uma função com o mesmo nome X, o tipo resultante terá uma função X identica, caso a funçao X seja identica em A e B ou sobrecarregada caso a função X possua assinatura diferente em A e B. 12345678910111213141516class A &#123; fn1(a: number): string &#123; return \"\"; &#125; fn2(): void &#123; &#125;&#125;class B &#123; fn1(b: string): number &#123; return 0; &#125; fn2(): void &#123; &#125;&#125;let x: A | B;// Aqui a função fn2 é do tipo: ((a: number) =&gt; string | (b: string) =&gt; number)let fn2 = x.fn1;// Aqui a função fn3 é do tipo: () =&gt; voidlet fn3 = x.fn2; InferênciaNuma operação ternária entre valores de tipos diferentes ... ? a : b o tipo do valor resultante será A | B. Numa operação lógica ou entre valores de tipos diferentes a || b o tipo do valor resultante será A | B. Num array de elementos de tipos diferentes [a, b, c, ...] o tipo deste array será inferido para A | B | C | .... ConclusãoEste post foi totalmente teórico e muito dos comportamentos descritos aqui podem ser percebidos de forma intuitiva, no entando, é sempre bom entender um pouco mais esses fundamentos. Até a próxima! Reference: TS v1.4 https://github.com/Microsoft/TypeScript/pull/824","categories":[{"name":"TypeScript","slug":"TypeScript","permalink":"http://diullei.com/categories/TypeScript/"},{"name":"TypeScript v1.4","slug":"TypeScript/TypeScript-v1-4","permalink":"http://diullei.com/categories/TypeScript/TypeScript-v1-4/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://diullei.com/tags/JavaScript/"},{"name":"TypeScript","slug":"TypeScript","permalink":"http://diullei.com/tags/TypeScript/"}]},{"title":"Configurando o TypeScript 2.0 Beta no VSCode","slug":"TypeScript2-Beta-no-vscode","date":"2016-07-13T22:00:00.000Z","updated":"2019-01-07T23:15:42.331Z","comments":true,"path":"2016/07/14/TypeScript2-Beta-no-vscode/","link":"","permalink":"http://diullei.com/2016/07/14/TypeScript2-Beta-no-vscode/","excerpt":"Tenho escrito alguns posts falando sobre as novidades do TypeScript 2.0 Beta que foi lançado há alguns dias e algumas pessoas vieram me perguntar como utilizar essa nova versão no Visual Studio Code (vscode). Resolvi escrever este post para mostrar com é fácil fazer esta configuração. O legal é que podemos fazer esta configuração por projeto, ou seja, posso ter projetos diferentes utilizando versões diferentes do TypeScript sem a necessidade de alterar a minha instalação global :)","text":"Tenho escrito alguns posts falando sobre as novidades do TypeScript 2.0 Beta que foi lançado há alguns dias e algumas pessoas vieram me perguntar como utilizar essa nova versão no Visual Studio Code (vscode). Resolvi escrever este post para mostrar com é fácil fazer esta configuração. O legal é que podemos fazer esta configuração por projeto, ou seja, posso ter projetos diferentes utilizando versões diferentes do TypeScript sem a necessidade de alterar a minha instalação global :) Configurando um novo projetoCrie um diretório para o seu projeto e execute dentro deste diretório o seguinte comando: npm init -y Isso irá criar um arquivo de configuração padrão do npm chamado package.json. Agora vamos instalar a versão desejada do TypeScript. No nosso caso vamos instalar a versão 2.0 Beta: npm install typescript@beta Esse comando irá instalar o TypeScript dentro de uma pasta local chamada node_modules. Feito isso vamos abrir o vscode e criar um outro arquivo de configuração que irá informar ao vscode que ele deverá utilizar a versão do TypeScript instalada dentro da pasta node_modules local. Abra o vscode e vá em File &gt; Preferences &gt; Workspace Settings. note que serão abertos 2 arquivos lado a lado. O arquigo settings.json será criado dentro de um diretório chamado .vscode e é esse arquivo que iremos alterar para informar ao vscode que sempre que estivermos neste diretório a versão do TypeScript que deverá ser utilizada será a versão 2.0 Beta instalada via npm. Para isso altere o conteúdo deste arquivo para o seguinte: { &quot;typescript.tsdk&quot;: &quot;node_modules/typescript/lib&quot; } Feito isso salve o arquivo. Pronto! Vamos agora testar para entender se tudo foi configurado corretamente. Crie um arquivo chamado tsconfig.json e insira o seguinte código: { &quot;compilerOptions&quot;: { &quot;target&quot;: &quot;es5&quot;, &quot;module&quot;: &quot;commonjs&quot;, &quot;moduleResolution&quot;: &quot;node&quot;, &quot;isolatedModules&quot;: false, &quot;jsx&quot;: &quot;react&quot;, &quot;experimentalDecorators&quot;: true, &quot;emitDecoratorMetadata&quot;: true, &quot;declaration&quot;: false, &quot;noImplicitAny&quot;: true, &quot;noImplicitUseStrict&quot;: true, &quot;removeComments&quot;: true, &quot;noLib&quot;: false, &quot;preserveConstEnums&quot;: true, &quot;suppressImplicitAnyIndexErrors&quot;: true, &quot;strictNullChecks&quot;: true }, &quot;exclude&quot;: [ &quot;node_modules&quot; ] } Agora crie um novo arquivo chamado exemplo.ts e insirea o seguinte código: 1234declare let names: string[] | undefined;// Error! 'names' is possibly undefined.let upperCased = names!.map(s =&gt; s.toUpperCase()); Feito isso tente compilar esse código com o comando Ctrl+shift+B. Repare que o vscode irá exibir uma mensagem dizendo: No task runner configured. Clique no botão Configue Task Runner exibido ao lado direito dessa mensagem e selecione TypeScript - tsconfig.json na lista de opções que será exibida. Com isso o vscode irá criar um novo arquivo dentro da pasta .vscode chamado tasks.json. Altere a linha &quot;command&quot;: &quot;tsc&quot; para &quot;command&quot;: &quot;node_modules/.bin/tsc&quot;. Reinicie o vscode e tente executar novamente o comando de build Ctrl+shift+B. Se tudo foi configurado corretamente o vscode irá compilar o código do arquivo exemplo.ts utilizando a versão local do TypeScript configurada. Note que se você remover o operador ! da linha 4 o vscode já ira informar um erro parecido com &#39;names&#39; is possibly undefined. É isso. Agora você já pode testar novas features do TypeScript 2.0 no vscode \\o/","categories":[{"name":"TypeScript","slug":"TypeScript","permalink":"http://diullei.com/categories/TypeScript/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://diullei.com/tags/JavaScript/"},{"name":"TypeScript","slug":"TypeScript","permalink":"http://diullei.com/tags/TypeScript/"},{"name":"VSCode","slug":"VSCode","permalink":"http://diullei.com/tags/VSCode/"}]},{"title":"TypeScript - Union Types","slug":"union-types","date":"2016-07-12T22:00:00.000Z","updated":"2019-01-07T23:15:42.331Z","comments":true,"path":"2016/07/13/union-types/","link":"","permalink":"http://diullei.com/2016/07/13/union-types/","excerpt":"Uma das caracteristicas do JavaScript é que podemos facilmente alterar o tipo de uma variável em tempo de execução simplesmente atribuindo um valor de tipo diferente a esta variável. No momento em que o valor é atribuido o tipo desta variável se altera e a partir daí inúmeros bugs podem surgir se não estivermos atentos. Em Typecript quando declaramos uma variável com um tipo específico, string por exemplo, ela carregará este tipo até o fim, ou seja, em nenhum momento será permitida a atribuição de um valor de tipo diferente nesta variável. let val: string; // Erro! val só pode receber um valor do tipo string val = false;","text":"Uma das caracteristicas do JavaScript é que podemos facilmente alterar o tipo de uma variável em tempo de execução simplesmente atribuindo um valor de tipo diferente a esta variável. No momento em que o valor é atribuido o tipo desta variável se altera e a partir daí inúmeros bugs podem surgir se não estivermos atentos. Em Typecript quando declaramos uma variável com um tipo específico, string por exemplo, ela carregará este tipo até o fim, ou seja, em nenhum momento será permitida a atribuição de um valor de tipo diferente nesta variável. let val: string; // Erro! val só pode receber um valor do tipo string val = false; O que ocorre é que em JavaScript ocasionalmente teremos variáveis ou parâmetros que irão esperar receber em momentos diferentes, valores de tipos diferentes. Quando configuramos uma requisição ajax no jQuery por exemplo (jQuery ajax doc), a propriedade jsonp pode assumir o valor false ou um valor do tipo string. Prevendo esse comportamente o TypeScript definiu um tipo chamado any. Esse tipo aceita qualquer valor de qualquer tipo. O problema aqui é que nem sempre declarar uma variável como any resolverá nosso problema. Pra que isso fique bem claro vamos a um exemplo: 12345678910111213141516/** * Takes a string and adds \"padding\" to the left. * If 'padding' is a string, then 'padding' is appended to the left side. * If 'padding' is a number, then that number of spaces is added to the left side. */function padLeft(value: string, padding: any) &#123; if (typeof padding === \"number\") &#123; return Array(padding + 1).join(\" \") + value; &#125; if (typeof padding === \"string\") &#123; return padding + value; &#125; throw new Error(`Expected string or number, got '$&#123;padding&#125;'.`);&#125;padLeft(\"Hello world\", 4); // retorna \" Hello world\" Note que no código acima o parâmetro padding está sendo declarado como any. O que não impede que que passemos um valor diferente de string ou number como por exemplo o valor true. O código acima compila normalmente sem nenhum erro mas falha no momento da execução. // compila sem erros mas falha no momento da execução let indentedString = padLeft(&quot;Hello world&quot;, true); Para contornar esse problema o TypeScript possui uma classe especial de declaração de tipos chamado de “union types” que permite definir no momento da escrita do código quais os valores que serão aceitos pelo parâmetro ou pela variável. Para isso utilizamos o operador |. Veja que no código acima que queremos que padding seja um parâmetros de tipo menos permissivo e aceite apenas valores do tipo string ou number e para isso alteramos a assinatura do tipo de any para string | number. Vamos alterar a assinatura da função padLeft para demonstrar esse recurso: 123456function padLeft(value: string, padding: string | number) &#123; //...&#125;// erro durante a compilaçãolet indentedString = padLeft(\"Hello world\", true); Agora temos uma falha no momento da compilação do código. O que aconteceu? O compilador do TypeScript entendeu que padding pode assumir apenas um valor string ou number. Veja como esse recurso nos ajuda a proteger o código de possíveis erros que passariam despercebidos. É isso. Até a próxima! Reference: TS v1.4 https://github.com/Microsoft/TypeScript/pull/824","categories":[{"name":"TypeScript","slug":"TypeScript","permalink":"http://diullei.com/categories/TypeScript/"},{"name":"TypeScript v1.4","slug":"TypeScript/TypeScript-v1-4","permalink":"http://diullei.com/categories/TypeScript/TypeScript-v1-4/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://diullei.com/tags/JavaScript/"},{"name":"TypeScript","slug":"TypeScript","permalink":"http://diullei.com/tags/TypeScript/"}]},{"title":"TypeScript 2.0 Beta - Non nullable types (Tipos não nulos)","slug":"TypeScript2-Beta-nun-nullable-types","date":"2016-07-11T22:00:00.000Z","updated":"2019-01-07T23:15:42.331Z","comments":true,"path":"2016/07/12/TypeScript2-Beta-nun-nullable-types/","link":"","permalink":"http://diullei.com/2016/07/12/TypeScript2-Beta-nun-nullable-types/","excerpt":"O TypeScript 2.0 Beta desembarcou com muitas novidades. Veja aqui o post original no blog da Microsoft. No decorrer dos próximos posts vou falar um pouco mais sobre as features dessa nova versão. Para iniciar, hoje quero falar sobre um dos recursos que eu já estava acompanhando e achei muito legal: a definição de tipos não nulos. Antes, para que possamos seguir com os exemplo que irei colocar aqui no post vamos instalar essa nova versão: npm install -g typescript@beta Com este release você já pode testar (caso não tenha testado ainda) a utilização dos dtss direto do npm. Escrevi sobre isso nesse outro artigo.","text":"O TypeScript 2.0 Beta desembarcou com muitas novidades. Veja aqui o post original no blog da Microsoft. No decorrer dos próximos posts vou falar um pouco mais sobre as features dessa nova versão. Para iniciar, hoje quero falar sobre um dos recursos que eu já estava acompanhando e achei muito legal: a definição de tipos não nulos. Antes, para que possamos seguir com os exemplo que irei colocar aqui no post vamos instalar essa nova versão: npm install -g typescript@beta Com este release você já pode testar (caso não tenha testado ainda) a utilização dos dtss direto do npm. Escrevi sobre isso nesse outro artigo. Tipos não nulos (Non-nullable Types)Essa feature sem dúvidas é uma das mais legais dessa nova versão. null e undefined são a origem comum de quase todos os bugs introduzidos durante a programação em JavaScript onde null se aplica a objetos e undefined a variáveis, propriedades e funções (pretendo falar mais sobre isso em outro artigo). Nas versões anteriores do TypeScript o tipo null e o undefined faziam parte do dominio de todos os outros tipos, ou seja, uma variável declarada como string poderia em algum momento assumir um valor null. Com o TypeScript 2.0 a utilização do novo flag --strictNullChecks durante a compilação muda essa lógica. Agora uma variável do tipo string passar a ser apenas do tipo string e nada mais. Exemplo: let valor: string = null; // Error Mas pera ai, e seu eu quiser que a variável valor aceite tanto um valor do tipo string quanto um valor nulo? Simples, basta utilizar o recurso union types. Exemplo: let valor: string | null = null; // Ok! Isso transfere para o desenvolvedor a decisão de aceitar ou não um valor null ou undefined e protege o código contra bugs que passariam despercebidos. Agora observe o seguinte trecho de código: declare let names: string[] | undefined; // Error! &apos;names&apos; is possibly undefined. let upperCased = names.map(s =&gt; s.toUpperCase()); No exemplo acima teremos um erro. O compilador do TypeScript entende que names pode ser undefined devido a sua declaração string[] | undefined. Mas se tivermos certeza de que nesse caso names nunca será undefined e quisermos que este código execute mesmo assim podemos utilizar o operador ! como a seguir: let upperCased = names!.map(s =&gt; s.toUpperCase()); Ao utilizar o oerador ! na variável names! estamos dizendo ao compilador que temos certeza de que essa variável nunca será undefined neste ponto do código. Aplicação em parâmetros e propriedades opcionaisUma ressalva com relação a declarações opcionais. Todo parâmetro ou propriedade opcional tem de forma automática o tipo undefined agregado ao seu tipo original, mesmo quando isso não é declarado de forma explicita no código. por exemplo: 123// Compilado com --strictNullCheckstype T1 = (x?: number) =&gt; string; // x é do tipo: number | undefinedtype T2 = (x?: number | undefined) =&gt; string; // x é do tipo: number | undefined por isso um parâmetro ou propriedade opcional sempre será nullable. NOTA: Para compilar os exemplos de código acima via linha de comando basta salvar o codigo em um arquivo e executar: tsc file.ts --strictNullChecks É isso aí pessoal, até a próxima! Reference: TS v2.0 https://github.com/Microsoft/TypeScript/pull/7140","categories":[{"name":"TypeScript","slug":"TypeScript","permalink":"http://diullei.com/categories/TypeScript/"},{"name":"TypeScript v2.0","slug":"TypeScript/TypeScript-v2-0","permalink":"http://diullei.com/categories/TypeScript/TypeScript-v2-0/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://diullei.com/tags/JavaScript/"},{"name":"TypeScript","slug":"TypeScript","permalink":"http://diullei.com/tags/TypeScript/"}]},{"title":"DefinitelyTyped + TypeScript team = TS FTW","slug":"DefinitelyTyped-and-TypeScript-Team","date":"2016-07-10T22:00:00.000Z","updated":"2019-01-07T23:15:42.331Z","comments":true,"path":"2016/07/11/DefinitelyTyped-and-TypeScript-Team/","link":"","permalink":"http://diullei.com/2016/07/11/DefinitelyTyped-and-TypeScript-Team/","excerpt":"Passando rápido aqui para falar de uma parceria muito legal que irá somar muito para a comunidade TypeScript, na realidade já começou a somar! Por alguns anos nós do time DefinitelyTyped temos nos esforçado muito para manter o repositório atualizado e servir os melhores dtss. Não é uma tarefa fácil, somos um time bastante distribuído pelo mundo, temos gente do Japão, Holanda, EUA, Australia, Russia, Brasil :) entre outros lugares… todos temos nossos afazeres, nosso trabalho e tarefas pessoais e por dedicação temos cedido parte do nosso tempo ajudando essa comunidade que tem se tornado cada vez mais forte a crescer. Hoje contamos com quase 2000 dts, fruto de muito esforço de muitos membros da comunidade juntamente com nosso time.","text":"Passando rápido aqui para falar de uma parceria muito legal que irá somar muito para a comunidade TypeScript, na realidade já começou a somar! Por alguns anos nós do time DefinitelyTyped temos nos esforçado muito para manter o repositório atualizado e servir os melhores dtss. Não é uma tarefa fácil, somos um time bastante distribuído pelo mundo, temos gente do Japão, Holanda, EUA, Australia, Russia, Brasil :) entre outros lugares… todos temos nossos afazeres, nosso trabalho e tarefas pessoais e por dedicação temos cedido parte do nosso tempo ajudando essa comunidade que tem se tornado cada vez mais forte a crescer. Hoje contamos com quase 2000 dts, fruto de muito esforço de muitos membros da comunidade juntamente com nosso time. O time do TypeScript sempre se manteve perto da gente acompanhando nossa evolução e trabalho, e recentemente tivemos o prazer de receber um apoio muito bem vindo! O Time do TypeScript se agregou ao time DefinitelyTyped e desde então começaram a nos ajudar com os PR’s. Há um mês atraz mais ou menos tinhamos pelo menos uns 200 PR’s pendentes/dia, muita contribuição para dar conta rs… e agora com essa ajuda de peso estamos conseguindo manter uma média de 50 PR’s pendentes/dia. Tem sido uma parceria muito legal. Um dos primeiros passos foi levar os dts’s para o npm (falei um pouco sobre isso neste artigo), e isso não para por ai, o DefinitelyTyped definitivamente faz parte do ciclo de desenvolvimento em TypeScript e muita coisa boa está por vir. Não posso adiantar muita coisa ainda, mas o que posso dizer é que todos nós ganharemos muito com tudo o que está sendo planejado. Espero logo logo trazer mais novidades! Abraços!","categories":[{"name":"TypeScript","slug":"TypeScript","permalink":"http://diullei.com/categories/TypeScript/"},{"name":"DefinitelyTyped","slug":"TypeScript/DefinitelyTyped","permalink":"http://diullei.com/categories/TypeScript/DefinitelyTyped/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://diullei.com/tags/JavaScript/"},{"name":"TypeScript","slug":"TypeScript","permalink":"http://diullei.com/tags/TypeScript/"}]},{"title":"TypeScript e o futuro dos arquivos de declaração","slug":"The-Future-of-Declaration-Files","date":"2016-07-08T22:00:00.000Z","updated":"2019-01-07T23:15:42.331Z","comments":true,"path":"2016/07/09/The-Future-of-Declaration-Files/","link":"","permalink":"http://diullei.com/2016/07/09/The-Future-of-Declaration-Files/","excerpt":"Alguns anos se passaram desde que a primeira versão do TypeScript veio a público. Agora quando a versão 2.0 está quase sendo lançada vemos o quanto esse projeto evoluiu. Uma das mudanças significativas desta nova versão é com relação aos arquivos de definição. Até hoje, para encontrar um arquivo de definição nós tinhamos 2 opções: ir até o repositório do DefinitelyTyped no github e baixar manualmente o arquivo ou utilizar uma das ferramentas criadas para automatizar esse trabalho, o TSD ou o typings.","text":"Alguns anos se passaram desde que a primeira versão do TypeScript veio a público. Agora quando a versão 2.0 está quase sendo lançada vemos o quanto esse projeto evoluiu. Uma das mudanças significativas desta nova versão é com relação aos arquivos de definição. Até hoje, para encontrar um arquivo de definição nós tinhamos 2 opções: ir até o repositório do DefinitelyTyped no github e baixar manualmente o arquivo ou utilizar uma das ferramentas criadas para automatizar esse trabalho, o TSD ou o typings. Pensando em melhorar esse trabalho o time do TypeScript está colocando suporte à instalaçao desses arquivos direto do npm. Como um dos administradores do grupo DefinitelyTyped eu me sinto muito feliz por saber que fizemos parte dessa mudança ajudando o time do TypeSript a entender como os membros da comunidade desenvolvem e utilizam esses arquivos. O DefinitelyTyped se tornou o repositório central dos arquivos de definição para o Typescript e é a partir dele que os pacotes no npm são gerados. Agora para instalar por exemplo a definição do lodash podemos utilizar a seguinte linha de comando: npm install --save @types/lodash Com isso seremos capazes de utilizar o lodash no nosso código TypeScript. Exemplo: 12import * as _ from &quot;lodash&quot;;_.padStart(&quot;Hello TypeScript!&quot;, 20, &quot; &quot;); Uma lista de todas as tipagens disponíveis pode ser encontrada neste link: https://aka.ms/types. Se você nao quiser esperar até o release da versão 2.0 você pode instalar o nightly builds. Apenas execute: npm install -g typescript@next Ferramentas como o TSD e o typings continuarão funcionando mas com certeza será muito mais interessante utilizar o npm. Bem, é isso, Até a próxima!","categories":[{"name":"TypeScript","slug":"TypeScript","permalink":"http://diullei.com/categories/TypeScript/"},{"name":"TypeScript v2.0","slug":"TypeScript/TypeScript-v2-0","permalink":"http://diullei.com/categories/TypeScript/TypeScript-v2-0/"},{"name":"DefinitelyTyped","slug":"TypeScript/TypeScript-v2-0/DefinitelyTyped","permalink":"http://diullei.com/categories/TypeScript/TypeScript-v2-0/DefinitelyTyped/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://diullei.com/tags/JavaScript/"},{"name":"TypeScript","slug":"TypeScript","permalink":"http://diullei.com/tags/TypeScript/"}]},{"title":"Spread Operator (Operador de Propagação)","slug":"spread-operator","date":"2016-02-04T23:00:00.000Z","updated":"2019-01-07T23:15:42.331Z","comments":true,"path":"2016/02/05/spread-operator/","link":"","permalink":"http://diullei.com/2016/02/05/spread-operator/","excerpt":"No ultimo artigo eu falei de forma bem rapida e simple sobre um recurso muito interessante do TypeScript rest parameters. Seguindo esta mesma linha hoje eu quero falar sbore um outro recuro muito legal chamado spread operator. O Spread Operator (Operador de Propagação) permite que uma expressão seja expandida em locais onde são esperados vários argumentos (chamadas de função) ou múltiplos elementos (arrays literais). Para entender melhor este recurso, como de costume vamos a um exemplo: 123456789function myFunc(...val: string[]) &#123; //...&#125;let animals = [&apos;dog&apos;, &apos;cat&apos;];myFunc(&apos;dog&apos;, &apos;cat&apos;);myFunc(...animals); Veja que a função myFunc possui um parâmetro do tipo rest parameter. Para entender sobre rest parameter veja o meu ultimo artigo. Esta função pode ser chamada opcionalmente passando um array seguindo a mesma sintaxe usada na assinatura da função ...: myFunc(...animals); onde animals é o nosso array: let animals = [&#39;dog&#39;, &#39;cat&#39;];","text":"No ultimo artigo eu falei de forma bem rapida e simple sobre um recurso muito interessante do TypeScript rest parameters. Seguindo esta mesma linha hoje eu quero falar sbore um outro recuro muito legal chamado spread operator. O Spread Operator (Operador de Propagação) permite que uma expressão seja expandida em locais onde são esperados vários argumentos (chamadas de função) ou múltiplos elementos (arrays literais). Para entender melhor este recurso, como de costume vamos a um exemplo: 123456789function myFunc(...val: string[]) &#123; //...&#125;let animals = [&apos;dog&apos;, &apos;cat&apos;];myFunc(&apos;dog&apos;, &apos;cat&apos;);myFunc(...animals); Veja que a função myFunc possui um parâmetro do tipo rest parameter. Para entender sobre rest parameter veja o meu ultimo artigo. Esta função pode ser chamada opcionalmente passando um array seguindo a mesma sintaxe usada na assinatura da função ...: myFunc(...animals); onde animals é o nosso array: let animals = [&#39;dog&#39;, &#39;cat&#39;]; Recuperando valores com destrutoresPodemos facilmente recuperar os valores dentro da função myFunc utilizando um recurso chamado Destructuring (Veremos este recurso com mais detalhes em outro artigo). Exemplo: 1234function myFunc(...val: string[]) &#123; let [val1, val2] = val; //...&#125; Note que estamos “destruindo” o valor do array val em 2 outras variáveis val1 e val2. Sendo val um array, estamos criando uma variavel val1 com o primeiro valor de val e uma outra variavel val2 com o segundo valor de val. Este recurso também pode ser utilizado na construção de arrays: 12let array1 = [1, 2, 3];let array2 = [0, ...array1, 4, 5, 6]; onde retemos o valor de array2 como: [0, 1, 2, 3, 4, 5, 6]. Aqui temos outro exemplo concatenando 2 arrays usando a função push: 123var arr1 = [0, 1, 2];var arr2 = [3, 4, 5];arr1.push(...arr2); O código acima seria similar à utilização da função concat. Este reurso está definido na especificação do ES6 e não foi totalmente implementado no TypeScript ainda. Exemplo de sintax que ainda não funciona no TypeScript mas que já pode ser testado utilizando o babeljs por exemplo: 123function foo(x, y, z) &#123; &#125;let args = [0, 1, 2];foo(...args); Repare que no exemplo acima o valor do array args está sendo “destruído” para alimentar os argumentos da função foo. Para saber mais sobre Spread Operators no ES6 acesse aqui. É isso, Abraços! Reference: TS v1.5 https://github.com/Microsoft/TypeScript/pull/1931","categories":[{"name":"TypeScript","slug":"TypeScript","permalink":"http://diullei.com/categories/TypeScript/"},{"name":"TypeScript v1.5","slug":"TypeScript/TypeScript-v1-5","permalink":"http://diullei.com/categories/TypeScript/TypeScript-v1-5/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://diullei.com/tags/JavaScript/"},{"name":"TypeScript","slug":"TypeScript","permalink":"http://diullei.com/tags/TypeScript/"}]},{"title":"TypeScript - Rest Parameters","slug":"rest-parameters","date":"2016-01-14T23:00:00.000Z","updated":"2018-01-27T19:37:41.224Z","comments":true,"path":"2016/01/15/rest-parameters/","link":"","permalink":"http://diullei.com/2016/01/15/rest-parameters/","excerpt":"","text":"Hoje vou falar rapidamente sobre um recurso muito legal do TypeScript: rest parameters. Se você programa em C# você vai entender bem o conceito, é uma feature similar ao params. No TypeScript este recurso nos permite recuperar todos os parâmetros informados para uma função como um unico argumento do tipo array. Para entender melhor nada melhor do que um exemplo: 1234567function buildName(firstName: string, ...restOfName: string[]) &#123; return firstName + &quot; &quot; + restOfName.join(&quot; &quot;);&#125;let employeeName = buildName(&quot;Diullei&quot;, &quot;de&quot;, &quot;Moura&quot;, &quot;Gomes&quot;);//=&gt; Diullei de Moura Gomes Note que a assinatura desta função declara 2 parâmetros diferentes: firstName: string e ...restOfName: string[]. Ao utilizarmos o símbolo ... na declaração do segundo argumento estamos dizendo ao compilador que todos os argumentos passados a para a função buildName a partir do segundo serão agrupados em um array do tipo string. Note que o operador ... só pode ser aplicado a um argumento do tipo array e que este precisa ser sempre o ultimo argumento da função. Este recurso é chamado de Rest Parameter. Este não é um recurso original do TypeScript e já havia sido definido para o ES6 (para saber mais sobre rest parameters no ES6). Abraços!","categories":[{"name":"TypeScript","slug":"TypeScript","permalink":"http://diullei.com/categories/TypeScript/"},{"name":"TypeScript v1.0","slug":"TypeScript/TypeScript-v1-0","permalink":"http://diullei.com/categories/TypeScript/TypeScript-v1-0/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://diullei.com/tags/JavaScript/"},{"name":"TypeScript","slug":"TypeScript","permalink":"http://diullei.com/tags/TypeScript/"}]},{"title":"Testando o TypeScript no VSCode (Visual Studio Code)","slug":"TypeScript-vscode","date":"2015-12-02T23:00:00.000Z","updated":"2019-01-07T23:15:42.327Z","comments":true,"path":"2015/12/03/TypeScript-vscode/","link":"","permalink":"http://diullei.com/2015/12/03/TypeScript-vscode/","excerpt":"O VSCode é um editor multiplataforma criado pela Microsoft destinado ao desenvolvimento de diversas aplicações contando com o suporte a várias linguagens de programação. O Visual Studio Code foi criado pelo time da Microsoft usando uma mistura de tecnologias de código aberto e baseadas na web, como o Chromium, o Electron app framework do GitHub e o próprio editor Monaco da Microsoft. Para facilitar a escrita a partir de agora sempre irei me referir ao visual Studio Code simplesmente como VSCode. Instalando o VSCodePara instalar o VSCode acesse a página do projeto https://www.visualstudio.com/en-us/products/code-vs.aspx e vá até a seção Download. Selecione a versão do seu sistem operacional e sigua as isntruções de instalação. Criando o primeiro projeto TypeScriptNeste pequeno tutorial iremos criar um projeto TypeScript simples. Para iniciar crie um novo diretório chamado MyProject. 1mkdir MyProject","text":"O VSCode é um editor multiplataforma criado pela Microsoft destinado ao desenvolvimento de diversas aplicações contando com o suporte a várias linguagens de programação. O Visual Studio Code foi criado pelo time da Microsoft usando uma mistura de tecnologias de código aberto e baseadas na web, como o Chromium, o Electron app framework do GitHub e o próprio editor Monaco da Microsoft. Para facilitar a escrita a partir de agora sempre irei me referir ao visual Studio Code simplesmente como VSCode. Instalando o VSCodePara instalar o VSCode acesse a página do projeto https://www.visualstudio.com/en-us/products/code-vs.aspx e vá até a seção Download. Selecione a versão do seu sistem operacional e sigua as isntruções de instalação. Criando o primeiro projeto TypeScriptNeste pequeno tutorial iremos criar um projeto TypeScript simples. Para iniciar crie um novo diretório chamado MyProject. 1mkdir MyProject Abra o VSCode e abra o diretório MyProject de dentro do VSCode. Agora, usando o sidebar Explorer, vamos adicionar um novo arquivo chamado tsconfig.json. Digite { } e com o cursor no meio das chaves pessione Ctrl+SPACE para abrir as opções disponíveis: Selecione compilerOptions e pressione ENTER. Vamos configurar o output do projeto para ES5, modulo do tipo AMD e emissão de source maps. 1234567&#123; \"compilerOptions\": &#123; \"target\": \"ES5\", \"module\": \"amd\", \"sourceMap\": true &#125;&#125; Agora vamos adicionar um novo arquivo chamado main.ts. Adicione o seguinte código: 123456789101112131415class Person &#123; private _name: string; constructor(name: string) &#123; this._name = name; &#125; public getName() &#123; return this._name; &#125;&#125;var person = new Person(&apos;joão&apos;);console.log(person.getName()); Tente compilar o projeto teclando Ctrl-Shift-B. Note que o VSCode irá exibir uma mensagem dizendo que não temos uma task configurada para o nosso projeto (Para saber mais sobre as tasks do vscode acesse: https://code.visualstudio.com/docs/editor/tasks). Clique em Configure Task Runner para adicionar uma nova task. um novo arquivo chamado tasks.json será criado. Altere a linha que contém a chave &quot;args&quot;: [&quot;HelloWorld.ts&quot;] para &quot;args&quot;: [] e em seguida tente compilar o projeto novamente utilizando Ctrl-Shift-B. O VSCode irá indicar na barra de status o status da compilação. Note que caso existam erros os memos serão indicados nada barra de status e você poderá clicar em cima do indicador para obter mais detalhes. Após a compilação o VSCode irá gerar os arquivos main.js e main.js.map. Trata-se do arquivo JavaScript gerado e do arquivo source map. Agora você pode utilizar o node via linha de comando para executar o código do arquivo main.js. 1node main.js Esse foi um tutorial bem simpels onde tentei apresentar o vscode e mostrar como é fácil iniciar um pequeno projeto em TypeScript. As features do vscode são muito voltadas para o desenvolvimento em TypeScript e eu te incentivo a explorar os varios recursos deste editor. Abraços!","categories":[{"name":"TypeScript","slug":"TypeScript","permalink":"http://diullei.com/categories/TypeScript/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://diullei.com/tags/JavaScript/"},{"name":"TypeScript","slug":"TypeScript","permalink":"http://diullei.com/tags/TypeScript/"}]},{"title":"TypeScript Guide","slug":"TypeScript-Guide","date":"2015-06-21T22:00:00.000Z","updated":"2019-01-07T23:15:42.327Z","comments":true,"path":"2015/06/22/TypeScript-Guide/","link":"","permalink":"http://diullei.com/2015/06/22/TypeScript-Guide/","excerpt":"Comecei a escrever um e-book sobre TypeScript e acredito que este livro poderá contribuir muito no aprendizado desta nova linguagem. Desde o seu release publico a 3 anos atrás o TypeScript tem se mostrado muito promissor e assumido um espaço muito importante no desenvolvido de aplicativos JavaScript. Creio que o TypeScript, a medida que o tempo for passando, vai se tornar uma linguagem bem popular e ter um bom guia escrito em português será de boa ajuda para muitos. Este livro é aberto a contribuições e pode ser acessar no endereço https://github.com/Diullei/typescript-guide. Estou escrevendo este livro utilizando o GitBook. Essa ferramenta é muito legal e vale apena conhecer se você estiver pensando em escrever um e-book :) No momento o e-book ainda está em construção e não possui muito conteúdo mas espero que em poucos meses possamos ter bastante coisas legais por lá!","text":"Comecei a escrever um e-book sobre TypeScript e acredito que este livro poderá contribuir muito no aprendizado desta nova linguagem. Desde o seu release publico a 3 anos atrás o TypeScript tem se mostrado muito promissor e assumido um espaço muito importante no desenvolvido de aplicativos JavaScript. Creio que o TypeScript, a medida que o tempo for passando, vai se tornar uma linguagem bem popular e ter um bom guia escrito em português será de boa ajuda para muitos. Este livro é aberto a contribuições e pode ser acessar no endereço https://github.com/Diullei/typescript-guide. Estou escrevendo este livro utilizando o GitBook. Essa ferramenta é muito legal e vale apena conhecer se você estiver pensando em escrever um e-book :) No momento o e-book ainda está em construção e não possui muito conteúdo mas espero que em poucos meses possamos ter bastante coisas legais por lá! Um pouco sobre minhas contribuições com TypeScriptTenho me envolvido com TypeScript desde sua primeira versão. Fui um dos primeiros a ajudar com as dúvidas sobre TypeScript no StackOverflow e tive a oportunidade de ser o primeiro membro colaborador do repositório DefinitelyTyped no Github juntamente com Boris Yankov (por curiosidade fui o segundo a enviar Pull Request para este repositório antes de ser agregado como colaborador, na época existiam apenas 12 tipagens diferentes, hoje contamos com mais de 1000). Este repositório veio a se tornar um dos repositórios mais indispensáveis para todos que desenvolvem em TypeScrpt atulamente contanto com a contribuição de mais de 1000 pessoas ao redor do mundo. Criei a organização DefinitelyTyped e fui o criador do TSD - TypeScript package Manager, ferramenta que tem feito parte do ciclo de desenvolvimento dos projetos que utilizam TypeScript atualmente (É possível utilizar o site do TSD para localizar as definições). Participei da criação do NugetAutomation, projeto que automatiza a publicação dos arquivos tipados publicados no repositório DefinitelyTyped para o nuget. recentemente me agregei ao time TypeStrong, este time tem feito grandes contribuições principalmente no desenvolvimento do pacote atom-typescript.","categories":[{"name":"TypeScript","slug":"TypeScript","permalink":"http://diullei.com/categories/TypeScript/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://diullei.com/tags/JavaScript/"},{"name":"TypeScript","slug":"TypeScript","permalink":"http://diullei.com/tags/TypeScript/"}]},{"title":"tsi - um REPL TypeScript","slug":"tsi-um-REPL-TypeScript","date":"2013-08-23T22:00:00.000Z","updated":"2018-01-27T19:37:41.224Z","comments":true,"path":"2013/08/24/tsi-um-REPL-TypeScript/","link":"","permalink":"http://diullei.com/2013/08/24/tsi-um-REPL-TypeScript/","excerpt":"","text":"Resolvi testar um modelo de screencast onde eu posto videos bem pequenos e práticos. Neste video inicial eu vou mostrar uma ferramenta bem legal que encontrei no github, um REPL typescript escrito pra nodejs. REPL (Read–eval–print loop) é um ambiente de programação iterativo que nos permite programar via linha de comando de forma dinamica. Até a próxima!","categories":[{"name":"TypeScript","slug":"TypeScript","permalink":"http://diullei.com/categories/TypeScript/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://diullei.com/tags/JavaScript/"},{"name":"TypeScript","slug":"TypeScript","permalink":"http://diullei.com/tags/TypeScript/"},{"name":"REPL","slug":"REPL","permalink":"http://diullei.com/tags/REPL/"}]},{"title":"TypeScript - Usando bower e tsd para instalar componentes e suas definições","slug":"TypeScript-Usando-bower-e-tsd-para-instalar-componentes-e-suas-definicoes","date":"2013-08-10T22:00:00.000Z","updated":"2019-01-07T23:15:42.327Z","comments":true,"path":"2013/08/11/TypeScript-Usando-bower-e-tsd-para-instalar-componentes-e-suas-definicoes/","link":"","permalink":"http://diullei.com/2013/08/11/TypeScript-Usando-bower-e-tsd-para-instalar-componentes-e-suas-definicoes/","excerpt":"Há algum tempo atrás eu criei uma ferramenta(tsd) que permite procurar e baixar via linha de comando vários arquivos de definição escritos em TypeScript. Estes arquivos são necessários caso você queira utilizar uma biblioteca como por exemplo o jquery ou o backbone com TypeScript. Para mais informações sobre arquivos de definição TypeScript veja este link.","text":"Há algum tempo atrás eu criei uma ferramenta(tsd) que permite procurar e baixar via linha de comando vários arquivos de definição escritos em TypeScript. Estes arquivos são necessários caso você queira utilizar uma biblioteca como por exemplo o jquery ou o backbone com TypeScript. Para mais informações sobre arquivos de definição TypeScript veja este link. Jonas Eriksson gravou um video bem legal mostrando como utilizar o bower e o tsd para instalar bibliotecas javascript junto com suas definições TypeScript no Visual Studio. O video ficou pequeno e bem objetivo. Segue abaixo: Até a próxima!","categories":[{"name":"TypeScript","slug":"TypeScript","permalink":"http://diullei.com/categories/TypeScript/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://diullei.com/tags/JavaScript/"},{"name":"TypeScript","slug":"TypeScript","permalink":"http://diullei.com/tags/TypeScript/"},{"name":"Bower","slug":"Bower","permalink":"http://diullei.com/tags/Bower/"},{"name":"tsd","slug":"tsd","permalink":"http://diullei.com/tags/tsd/"}]},{"title":"TypeScript (Parte 1)","slug":"TypeScript-Parte-1","date":"2013-08-09T22:00:00.000Z","updated":"2019-01-07T23:15:42.327Z","comments":true,"path":"2013/08/10/TypeScript-Parte-1/","link":"","permalink":"http://diullei.com/2013/08/10/TypeScript-Parte-1/","excerpt":"Embora eu já tenha escrito uma introdução sobre o TypeScript em outro artigo resolvi voltar ao tema e dessa vez escrever uma série de artigos sobre TypeScript. Neste post estarei novamente introduzindo o TypeScript. IntroduçãoCom o crescimento da internet e a necessidade cada vez maior de termos aplicações web expondo funcionalidades complexas de usabilidade no lado cliente (FrontEnd), têm se ampliado cada vez mais o uso do JavaScript para suportar toda esta infinidade de programação diretamente no navegador web. Nos últimos anos nossos computadores ficaram mais rápidos, nossos navegadores ficaram mais rápidos e com isso o JavaScript também teve seu curso de evolução natural ficando mais rápido devido ao grande investimento em tecnologia feito nos compiladores e ganhando inúmeros recursos. Hoje podemos ver uma explosão de frameworks surgindo a todo momento, falamos sobre MVC e padrões de projeto dentre outros assuntos como se estivessemos falando sobre linguagens clássicas como C++, Java ou C#. O JavaScript já ultrapassou as fronteiras da web e hoje podemos desenvolver aplicativos nativos para sistemas operacionais como no desenvolvimento de aplicativos para o Windows 8 por exemplo. Existem ainda outras tecnologias tais como Adobe AIR, Titanium, PhoneGap, AppJS, Boot2Gecko e Chromium. Estas são apenas algumas das plataformas que nos permitem desenvolver aplicativos para diversos sistemas operacionais.","text":"Embora eu já tenha escrito uma introdução sobre o TypeScript em outro artigo resolvi voltar ao tema e dessa vez escrever uma série de artigos sobre TypeScript. Neste post estarei novamente introduzindo o TypeScript. IntroduçãoCom o crescimento da internet e a necessidade cada vez maior de termos aplicações web expondo funcionalidades complexas de usabilidade no lado cliente (FrontEnd), têm se ampliado cada vez mais o uso do JavaScript para suportar toda esta infinidade de programação diretamente no navegador web. Nos últimos anos nossos computadores ficaram mais rápidos, nossos navegadores ficaram mais rápidos e com isso o JavaScript também teve seu curso de evolução natural ficando mais rápido devido ao grande investimento em tecnologia feito nos compiladores e ganhando inúmeros recursos. Hoje podemos ver uma explosão de frameworks surgindo a todo momento, falamos sobre MVC e padrões de projeto dentre outros assuntos como se estivessemos falando sobre linguagens clássicas como C++, Java ou C#. O JavaScript já ultrapassou as fronteiras da web e hoje podemos desenvolver aplicativos nativos para sistemas operacionais como no desenvolvimento de aplicativos para o Windows 8 por exemplo. Existem ainda outras tecnologias tais como Adobe AIR, Titanium, PhoneGap, AppJS, Boot2Gecko e Chromium. Estas são apenas algumas das plataformas que nos permitem desenvolver aplicativos para diversos sistemas operacionais. Usando TypeScript para desenvolver aplicações de grande escalaCom todo esse crescimento provocado pela adoção do JavaScript vem surgindo a preocupação em como gerenciar todo o código fonte produzido permitindo escalar esta produção da mesma forma que já acontece em outras linguagens de programação. Foi pensando nisso que a Microsoft lançou o TypeScript. Seu intuito é de ampliar a escala de construção de aplicativos fornecendo recursos avançados de analise de tipagem estática. O TypeScript leva o JavaScript para mais próximo dos desenvolvedores familiarizados com o conceito de orientação a objetos como programadores das linguagens C#, C++, Java entre outras. O TypeScript é um projeto OpenSource totalmente compatível com todos os navegadores e sistemas operacionais que já suportam o JavaScript. Na prática qualquer código JavaScript pode ser utilizando dentro do TypeScript (com algumas ressalvas que serão discutidas nos próximos posts) sendo que o resultado final será sempre JavaScript, com a facilidade de poder antecipar diversos erros que só pegaríamos em tempo de execução graças ao seu compilador. JavaScript e TypeScriptComo exemplo, considere o seguinte exemplo de código JavaScript: 123456789101112131415161718function Mensagem(texto) &#123; this.texto = texto;&#125;Mensagem.prototype.exibe = function() &#123; return \"Olá, \" + this.texto + \"!\";&#125;var mensagem = new Mensagem(&#123;texto: \"Mundo\"&#125;)var button = document.createElement(\"button\");button.innerText = \"Diga Olá!\";button.onclick = function() &#123; alert(mensagem.exibe());&#125;document.body.appendChild(button); Vamos compilar este código utilizando o compilador do TypeScrit para visualizar o código JavaScrit que será gerado. Para isso vamos utilizar o TypeScript Playground. TypeScript Playground - Trata se de um compilador TypeScript online onde podemos testar qualquer código TypeScript e visualizar a saída de código JavaScript em tempo real. Veja que na caixa a esquerda temos nosso código JavaScript original. Já na caixa a direita temos o código gerado pelo compilador do TypeScript, e você vai perceber que a saída de código é essencialmente parecida com o código JavaScript que foi introduzido, tirando algumas pequenas diferenças de espaço em branco. No entanto esse código JavaScript tem um bug. Devido a natureza dinâmica do JavaScrpt este bug passou despercebido durante o desenvolvimento deste código. Basta executar o código e veremos o erro ocorrendo: . Para tanto vamos alterar o código original e definir para o construtor do objeto Mensagem que seu argumento deverá ser sempre do tipo string. Segue abaixo o código alterado: 12345678910111213141516171819function Mensagem(texto: string) &#123; this.texto = texto;&#125;Mensagem.prototype.exibe = function() &#123; return \"Olá, \" + this.texto + \"!\";&#125;var mensagem = new Mensagem(&#123;texto: \"Mundo\"&#125;)var button = document.createElement(\"button\");button.innerText = \"Diga Olá!\";button.onclick = function() &#123; alert(mensagem.exibe());&#125;document.body.appendChild(button); Ao tentar compilar este código o compilador do TypeScript nos dará um erro na linha 9 por que estamos tentanto passar um objeto como argumento de um construtor que espera receber um argumento do tipo string conforme foi definido. Vamos utilizar o TypeScript Playground para ver isso na prática. Ao alterarmos o código na linha 1 definindo o tipo do argumento texto do TypeScript passou a emitir um erro na linha 9. Veja este erro com mais detalhe na imagem abaixo: Veja que esta simples definição de tipo permitiu ao compilador nos fornecer uma experiência de codificação muito melhor do que a que tivemos antes. Agora temos uma verificação estática do nosso código e um erro totalmente detalhado. Tendo esse ferramental a disposição conseguimos facilmente identificar e resolver o problema que antes havia passado por despercebido. Tendo uma definição de tipos bem feita podemos ter um IntelliSense de qualidade se estivermos utilizando uma IDE com suporte ao TypeScript. Veja por exemplo na imagem abaixo um autoComplete gerado quando tentamos acessar os membros do argumento texto da função Mensagem. Tipos declarados Vimos no tópico anterior que podemos escrever um código TypeScript definindo tipos e vimos o quanto isso pode ser util nos fornecendo uma checagem do código em tempo de compilação. Um outro recurso muito util do TypeScript é a possibilidade de “tipar” um código JavaScript existente. Isso é feito utilizando a palavra chave declare. digamos que a função Mesagem que estamos utilizando em nos exemplo já existisse em um arquivo JavaScript externo. 12345678function Mensagem(texto) &#123; this.texto = texto&#125;Mensagem.prototype.exibe = function() &#123; return \"Olá, \" + this.texto + \"!\";&#125; Agora queremo utilizar este método em nosso arquivo TypeScript. Sabemos que o arquivo acima será carregado em nossa página e se estivessemos escrevendo em JavaScript bastaria escrever um código que utilize está função e no momento em que este código fosse executado ele chamaria a função Mensagem como desejado. Como estamos escrevendo o código em TypeScript teremos um erro no momento da compilação por que a função Mensagem não está sendo definida no código TypeScript. Para resolver iremos declarar apenas a assinatura da função Mensagem como no código abaixo: 12declare var Mensagem: (texto: string) =&gt; any... Isso diz ao TypeScript que existe uma função chamada Mensagem que recebe um string com argumento e retorna um tipo qualquer. Note que estamos usando a palavra-chave declare. Esta função náo será criada quando o arquivo JavaScript for gerado pois serve apenas de apoio para o compilador. O código TypeScript poderia ficar assim: 123declare var Mensagem: (texto: string) =&gt; anyvar mensagem = new Mensagem(\"Mundo\") É possível “tipar” qualquer código JavaScript. Podemos “tipar” por exemplo o backbone ou o jquery e utilizar todo o poder da definição de tipos e outros recursos do TypeScript com estas bibliotecas existentes. Com isso teremos por exemplo auto-complete se estivermos utilizando uma IDE com suporte ao TypeScript e validação de tipos em tempo de compilação. Na realidade a comunidade TypeScript tem trabalhado bastante para “tipar” todas as bibliotecas JavaScript existentes. Existe um projeto chamado DefinitelyTyped do qual eu sou um dos administradores que mantém a maior coleção de arquivos JavaScript tipados para TypeScript. Se você der uma olhada no www.tsdpm.com verá que é possível recuperar estas definições via linha de comando ou NuGet. Melhores ferramentasA Microsoft a tempos tem defendido a idéia de que as linguagens de programação e as ferramentas de desenvolvimento devem trabalhar juntas para criar uma boa experiência de desenvolvimento. Como já foi dito com TypeScript os fornecedores de Editores e IDEs tem a possibilidade de prover para o desenvolvedor ferramentas que proporcionam uma experiência de desenvolvimento em TypeScript muito rica incluindo a verificação de tipos e interfaces, navegação de código, refatoração, debug, intelliSense entre outros. A própria Microsoft está disponibilizando um plugin para o Visual Studio 2012 com muitos destes recursos. Existem ainda outros editores no mercado trabalhando no suporte ao TypeScript. Veja mais neste link. TypeScript vs CoffeeScriptÉ fácil ouvir que o TypeScript tem muitas semelhanças com CoffeeScript. Ambos são destinados a fazer a mesma coisa: tornar o desenvolvimento JavaScript mais fácil. O CoffeeScript simplifica o JavaScript definindo uma nova sintaxe e permitindo ao desenvolvedor fazer muitas coisas de forma simples. Já o TypeScript é um superconjunto do JavaScript e tenta facilitar as coisas dando ao JavaScript mais estrutura principalmente provendo os recursos de tipagem estática. Um ponto importante a ser notado é que o TypeScript traz uma sintaxe com uma curva de aprendizado pequena para o desenvolvedor JavaScript o que não acontece com o CoffeeScript que traz uma sintaxe bem diferente e que o CoffeeScript não tem checagem estatica de tipos. Se você gosta de Ruby você provavelmente vai gostar mais do CoffeeScript do que do TypeScript. Se você gosta de C++/Java/C# o TypeScript será mais familiar. Para uma pequena demonstração segue abaixo um exemplo do mesmo código que estávamos trabalhando nos tópicos anteriores portado para CoffeeScript: 1234567891011121314class Mensagem constructor: @texto -&gt; exibe: -&gt; \"Olá, #&#123;@texto&#125;!\"mensagem = new Mensagem \"Mundo\"button = document.createElement \"button\"button.innerText = \"Diga Olá!\"button.onclick = -&gt; alert mensagem.exibe()document.body.appendChild button TypeScript vs DartO TypeScript e o Dart são semelhantes na medida em que podem gerar JavaScript, mas o Dart é muito mais do que apenas geração de código JavaScript. O Dart pretende ser uma alternativa ao JavaScript com uma linguagem totalmente nova tendo sua própria VM com a proposta de um melhor desempenho. O Dart pode ser executado diretamente no navegador utilizando um plugin, no servidor utilizando sua própria VM ou em qualquer ambiente JavaScript utilizando o seu código JavaScript gerado. Já o Typescript sempre é traduzido para JavaScript. Por que utilizar TypeScriptSe o CoffeeScript e o Dart são pré-processadores que fazem o mesmo que o TypeScript se propõe por que você deveria adotar o TypeScript? Entenda que o TypeScript foi construído foco em trabalhar junto com um Editor ou IDE fornecendo fortes recursos para o desenvolvedor e facilitando em muito sua vida. Vamos listar abaixo alguns pontos positivos relacionados a adoção do TypeScript. Por ser um superconjunto do JavaScript permite uma fácil transição de código JavaScript para código TypeScript. Código open source. A tipagem estática do TypeScript ajuda o desenvolvedor a detectar erros durante o desenvolvimento. Estes recursos são muito bem vindos para nós desenvolvedores. Antes precisávamos partir para soluções como: Script#, Google GWT que também tentam resolver estes problemas de tipagem estática. Promessa de grandes recursos como refatoração, navegação no código por referência dos tipos, debug, analises de código entre outros por parte dos Editores e IDEs como o Visual Studio 2012 por exemplo. Possibilidade de trabalhar com OO (classes, interfaces, herança etc…) sem ter que manipular diretamente os protótipos JavaScript para reproduzir este comportamento. Roda em qualquer ambiente com suporte a JavaScript ES3 ou superior. Isso permitiu por exemplo uma fácil distribuição do TypeScript em Node.JS. Assim o TypeScript pode ser fácilmente instalado em ambientes como Linux e MacOS. O Windows 8 está chegando pesado permitindo desenvolvimento de aplicativos utilizando HTML/CSS/JavaScript. Os futuros desenvolvedores de aplicativos para Windows 8 irão provavelmente utilizar TypeScript para este trabalho. Se todo o conteúdo apresentado até aqui foi o suficiente para convence-lo a aprender esta nova linguagem espero ver você nos próximos posts. Abraços!","categories":[{"name":"TypeScript","slug":"TypeScript","permalink":"http://diullei.com/categories/TypeScript/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://diullei.com/tags/JavaScript/"},{"name":"TypeScript","slug":"TypeScript","permalink":"http://diullei.com/tags/TypeScript/"}]},{"title":"Testando o ultimo build do TypeScript no VS","slug":"Testando-o-ultimo-build-do-TypeScript-no-VS","date":"2013-02-01T23:00:00.000Z","updated":"2019-01-07T23:15:42.327Z","comments":true,"path":"2013/02/02/Testando-o-ultimo-build-do-TypeScript-no-VS/","link":"","permalink":"http://diullei.com/2013/02/02/Testando-o-ultimo-build-do-TypeScript-no-VS/","excerpt":"IntroduçãoO objetivo deste post é mostrar como você pode atualizar a versão do TypeScript instalada na sua máquina com a ultima versão em desenvolvimento. Isso é legal caso você esteja acompanhando o que o time do TypeScript está preparando para as novas versões. Você vai precisar atualizar um arquivo chamado typescriptSerivces.js. Vamos ver como isso pode ser feito. Obtendo uma nova versão do arquivo typescriptSerivces.jsPrimeira opção: Usando o “LKG”LKG é uma sigla que significa “Last Known Good” que significa no nosso contexto algo como “ultimo arquivo bom de que temos conhecimento”. Você pode pegar uma cópia deste arquivo no CodePlex aqui, basta navegar até o diretorio bin e baixar o arquivo typescriptSerivces.js.","text":"IntroduçãoO objetivo deste post é mostrar como você pode atualizar a versão do TypeScript instalada na sua máquina com a ultima versão em desenvolvimento. Isso é legal caso você esteja acompanhando o que o time do TypeScript está preparando para as novas versões. Você vai precisar atualizar um arquivo chamado typescriptSerivces.js. Vamos ver como isso pode ser feito. Obtendo uma nova versão do arquivo typescriptSerivces.jsPrimeira opção: Usando o “LKG”LKG é uma sigla que significa “Last Known Good” que significa no nosso contexto algo como “ultimo arquivo bom de que temos conhecimento”. Você pode pegar uma cópia deste arquivo no CodePlex aqui, basta navegar até o diretorio bin e baixar o arquivo typescriptSerivces.js. Compilando a ultima versão do TypeScriptPré-requisitosVocê vai precisar das seguintes feramentas instaladas na tua máquina: Git - Algumas recomendações para instalação do git no windows Não instale com a opção de integração com o Windows Explorer a menos que você vá realmente precisar disso. Selecione a opção Run Git from the Windows Command Prompt. Selecione Checkout as-is and commit as-is Node.js Clonando o TypeScript&gt; git clone https://git01.codeplex.com/typescript Isso irá criar um diretório local chamado typescript com o código fonte do projeto. Selecionar o Branch da ultima versão em desenvolvimento&gt; cd typescript &gt; git checkout develop O branch develop é onde encontramos as ultimas alterações de código. Instalando as dependências do projeto&gt; npm install Isso irá instalar uma ferramenta clamada jake a qual é usada no build do TypeScript. Compilando o TypeScript&gt; .\\node_modules\\.bin\\jake local NOTA: Sempre que você quiser pegar a ultima versão do código do TypeScript para compilar localmente você pode apagar o folder typescript e repetir todo o procedomento acima ou simplesmente executar o comando git pull para atualizar seu repositório com as ultimas alterações feitas pelo time do TypeScript. Atualizando o arquivo typescriptSerivces.jsVocê vai precisar localizar o diretório local onde onde a extensão do TypeScrit está instalada. Procure por um arquivo chamada typescriptSerivces.js em um diretório localizado em um caminho paredico com: C:\\Program Files (x86)\\Microsoft Visual Studio 11.0\\Common7\\IDE\\Extensions\\enn4wcm5.z2b\\ Note que o ultimo diretório chamado enn4wcm5.z2b vai ter nome diferente em cada máquina. Em alguns casos raros você pode ter mais de um subfolde com a instalação do TypeScript. Se você tiver este cenário identifique pela data de criação o mais recente. Localize o arquivo typescriptSerivces.js, faça um backup e substitua este arquivo pela ultima versão optida no tópico anterior. Feito isso, reinicie o Visual Studio e divirta-se! Um grande abraço e até a próxima!","categories":[{"name":"TypeScript","slug":"TypeScript","permalink":"http://diullei.com/categories/TypeScript/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://diullei.com/tags/JavaScript/"},{"name":"TypeScript","slug":"TypeScript","permalink":"http://diullei.com/tags/TypeScript/"}]},{"title":"Debugando TypeScript no navegador","slug":"Debugando-TyprScript-no-navegador","date":"2012-10-15T22:00:00.000Z","updated":"2019-01-07T23:15:42.327Z","comments":true,"path":"2012/10/16/Debugando-TyprScript-no-navegador/","link":"","permalink":"http://diullei.com/2012/10/16/Debugando-TyprScript-no-navegador/","excerpt":"IntroduçãoExiste um recurso bem interessante implementado no Firefox e no Chrome (não sei ao certo quais outros navegadores) chamado Source Maps. Para entender do que se trata tenha em mente um arquivo javascript minificado. Para rastrear um bug no código deste arquivo por exemplo teríamos que usar a versão não minificada do mesmo. Uma vez encontrado o bug este seria corrigido e um novo arquivo minificado seria gerado. Um Source Map é um arquivo de mapeamento que faz um dê-para (no nosso caso) do arquivo minificado com o arquivo real. A partir deste mapeamento o browser consegue realizar o debug no arquivo original(não minificado) em bora a execução real esteja ocorrendo no arquivo minificado. Até aqui isso não agregou muito por que basta referenciar o arquivo original como dito anteriormente. Uma vez que tenhamos o problema rastreado ou a feature implementada minificamos tudo novamente.","text":"IntroduçãoExiste um recurso bem interessante implementado no Firefox e no Chrome (não sei ao certo quais outros navegadores) chamado Source Maps. Para entender do que se trata tenha em mente um arquivo javascript minificado. Para rastrear um bug no código deste arquivo por exemplo teríamos que usar a versão não minificada do mesmo. Uma vez encontrado o bug este seria corrigido e um novo arquivo minificado seria gerado. Um Source Map é um arquivo de mapeamento que faz um dê-para (no nosso caso) do arquivo minificado com o arquivo real. A partir deste mapeamento o browser consegue realizar o debug no arquivo original(não minificado) em bora a execução real esteja ocorrendo no arquivo minificado. Até aqui isso não agregou muito por que basta referenciar o arquivo original como dito anteriormente. Uma vez que tenhamos o problema rastreado ou a feature implementada minificamos tudo novamente. Como isso pode nos ajudar no Debug de código TypeScript?TypeScrit assim como CoffeeScrit e Dart entre outros são pré-processadores que geram no final das contas código JavaScript. Como a maioria dos pré-processadores tenta melhorar a sintaxe do código na escrita de expressões lambda, iterações, classes, interfaces, heranças e etc, temos uma dissonância entre o código escrito em TypeScript por exemplo com o código JavaScript gerado no final. Aqui entra em ação o Source Map. Com ele assim como podemos mapear um arquivo minificado com seu arquivo original, podemos também mapear um arquivo TypeScript original com seu código final gerado em JavaScript. Isso abre novas possibilidades de debug. Novas ferramentas de debug e refatoração podem ser criadas a partir deste recurso. É aí que entra o assunto deste artigo. Vou mostrar como debugar TypeScript em um navegador com suporte a Source Maps. No meu caso vamos usar o Chrome. Habilitando Source Map no Google ChromePara habilitar o recurso de source maps no Chrome basta acessar Settings e selecionar a caixa “Enable source maps”. Veja na imagem abaixo: Feito isso estamos pronto para debugar nosso código. Criando o nosso código de testesPara exemplo vamos criar um arquivo com um código TypeScript muito simples. Salve o código abaixo em um arquivo chamado 12345678910111213141516171819202122232425```javascriptinterface IPessoa&#123; nome: string; sobreNome: string; nomeCompleto: () =&gt; string;&#125;class Pessoa implements IPessoa &#123; nome: string; sobreNome: string; nomeCompleto(): string &#123; return &quot;Nome: &quot; + this.nome + &quot; &quot; + this.sobreNome; &#125;&#125;var pessoa = new Pessoa();pessoa.nome = &quot;Diullei&quot;;pessoa.sobreNome = &quot;Gomes&quot;;var element = document.getElementById(&apos;content&apos;);element.innerHTML = pessoa.nomeCompleto(); Agora crie um arquivo chamado e coloque o código abaixo:12345678910111213```javascript&lt;!DOCTYPE HTML&gt;&lt;html&gt;&lt;head&gt; &lt;meta&gt; &lt;title&gt;&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;div id=&quot;content&quot;&gt;&lt;/div&gt; &lt;script type=&quot;text/javascript&quot; src=&quot;script.js&quot;&gt;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; Estes arquivos precisam estar no mesmo folder. Source Maps para TypeScriptTendo nosso pequeno projeto em mãos agora precisamos gerar nosso arquivo source map. Felizmente o time que trabalha no TypeScript fez um trabalho muito bom incluindo um gerador de source maps no compilador do TypeScript. Embora não seja documentado no help do utilitário de compilação do TypeScript para gerar o arquivo sourcemap basta executar a compilação da seguinte forma: --sourcemap script.ts```. Feito isso repare que um arquivo chamado ```script.js.map``` é gerado. Repare também que este arquivo é referenciado no final do arquivo script.js gerado pelo compilador como na linha abaixo:12```//@ sourceMappingURL=script.js.map Tendo compilado o arquivo script.ts agora basta abrir a página index.html no Chrome. Coloque um breakpoint no código para ver o debug do TypeScript em ação. Veja na imagem abaixo: ConclusãoComo vimos o recurso Source Maps abre muitas possibilidades no tocante a rastreamento de código. Para saber mais sobre Source Maps acesse http://www.html5rocks.com/en/tutorials/developertools/sourcemaps/ Para saber mais sobre TypeScript acesse http://diullei.github.com/TypeScript-ptBR/ Um grande abraço e até a próxima!","categories":[{"name":"TypeScript","slug":"TypeScript","permalink":"http://diullei.com/categories/TypeScript/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://diullei.com/tags/JavaScript/"},{"name":"TypeScript","slug":"TypeScript","permalink":"http://diullei.com/tags/TypeScript/"},{"name":"Chrome","slug":"Chrome","permalink":"http://diullei.com/tags/Chrome/"},{"name":"SourceMaps","slug":"SourceMaps","permalink":"http://diullei.com/tags/SourceMaps/"}]},{"title":"Introdução ao TypeScript","slug":"Introducao-ao-TypeScript","date":"2012-10-11T22:00:00.000Z","updated":"2019-01-07T23:15:42.327Z","comments":true,"path":"2012/10/12/Introducao-ao-TypeScript/","link":"","permalink":"http://diullei.com/2012/10/12/Introducao-ao-TypeScript/","excerpt":"IntroduçãoA Microsoft surpreendeu todos a pouco tempo lançando seu próprio pré-processador de JavaScript chamado TypeScript. Muitos saíram comparando o TypeScript com CofeeScript chamando o TypeScript de “CoffeeScript da Microsoft”. Se investigarmos mais a fundo veremos que se trata de uma proposta diferente do CoffeeScript a começar pela sintaxe. Não sou programador CoffeeScript (embora já tenha trabalhado com Coffee não me considero um especialista) e por trabalhar com C# achei a curva de aprendizado do TypeScript muito suave. TypeScript nos permite escrever código puramente JavaScript mesclando ou não o código JavaScript convencional com seu incrível poder de “tipagem” e sintaxe amigável para codificação OO (Criação de classes e interfaces, utilização de herança etc). Não é minha intenção convencer você de que TypeScript é a melhor solução do mundo ou que é melhor do que CoffeeScript. Essas discussões no fim das contas não levam a nada. CoffeeScript tem seu espaço assim como o TypeScript. Se você já programou em alguma linguagem fortemente “tipada” como C#, Java ou C++ provavelmente você irá se sentir bem com os recursos fornecidas pelo TypeScript. Nem preciso dizer que se você programa em Python vai se sentir mais a vontade ao utilizar CoffeeScript do que com TypeScript :) Iniciei um trabalho de tradução da documentação do TypeScript. Você pode acessar a tradução da página oficial do TypeScript aqui http://diullei.github.com/TypeScript-ptBR/index.html. A documentação estará sendo traduzida no repositório do SampaJS no github e estará sendo disponibilizada em breve. Vamos a uma breve introdução sobre TypeScript. A intenção é apresentar alguns recursos básicos interessantes sobre a linguagem.","text":"IntroduçãoA Microsoft surpreendeu todos a pouco tempo lançando seu próprio pré-processador de JavaScript chamado TypeScript. Muitos saíram comparando o TypeScript com CofeeScript chamando o TypeScript de “CoffeeScript da Microsoft”. Se investigarmos mais a fundo veremos que se trata de uma proposta diferente do CoffeeScript a começar pela sintaxe. Não sou programador CoffeeScript (embora já tenha trabalhado com Coffee não me considero um especialista) e por trabalhar com C# achei a curva de aprendizado do TypeScript muito suave. TypeScript nos permite escrever código puramente JavaScript mesclando ou não o código JavaScript convencional com seu incrível poder de “tipagem” e sintaxe amigável para codificação OO (Criação de classes e interfaces, utilização de herança etc). Não é minha intenção convencer você de que TypeScript é a melhor solução do mundo ou que é melhor do que CoffeeScript. Essas discussões no fim das contas não levam a nada. CoffeeScript tem seu espaço assim como o TypeScript. Se você já programou em alguma linguagem fortemente “tipada” como C#, Java ou C++ provavelmente você irá se sentir bem com os recursos fornecidas pelo TypeScript. Nem preciso dizer que se você programa em Python vai se sentir mais a vontade ao utilizar CoffeeScript do que com TypeScript :) Iniciei um trabalho de tradução da documentação do TypeScript. Você pode acessar a tradução da página oficial do TypeScript aqui http://diullei.github.com/TypeScript-ptBR/index.html. A documentação estará sendo traduzida no repositório do SampaJS no github e estará sendo disponibilizada em breve. Vamos a uma breve introdução sobre TypeScript. A intenção é apresentar alguns recursos básicos interessantes sobre a linguagem. Instalando o TypeScriptO compilador do TypeScript é escrito em TypeScript e como o TypeScript compila pra JavaScript ele pode ser executado em qualquer ambiente JavaScript. Assim podemos rodar código TypeScript em qualquer navegador e inclusive no Node.js. Se você está habituado com o uso do Visual Studio vai ficar feliz! rs… é possível instalar um plugin no Visual Studio 2012 para trabalhar com TypeScript. Se você costuma utilizar Node.js vai se sentir mais a vontade utilizando o TypeScript no Node.js. Para ver como instalar o TypeScript no Node.js ou no Visual Studio acesse o link: http://diullei.github.com/TypeScript-ptBR/#Download. Se você quiser seguir este artigo sem ter o trabalho de instalar o TypeScript você pode utilizar o TypeScript Playground. Trata-se de um compilador online onde podemos experimentar o TypeScript. Direto ao códigoPara entender como as coisas funcionam vamos criar um código JavaScript bem simples. Este código será alterado no decorrer deste artigo e aos poucos irei apresentar alguns recursos do TypeScript. 1234567function saudacao(pessoa)&#123; return \"Olá \" + pessoa;&#125;var alguem = \"Diullei Gomes\";console.log(saudacao(alguem)); Crie um arquivo chamado saudacao.ts e salve com o código acima. Aqui repare que o arquivo TypeScript tem extensão “.ts”. Repare também que este código é um código JavaScript puro. Iremos alterar este código aos poucos. Execute saudacao.ts```(Se você instalou a versão Node.js) e veja que será criado um arquivo saudacao.js. Sempre que compilamos um arquivo \".ts\" o compilador do TypeScript gera um arquivo \".js\". Se você estiver utilizando o Visual Studio verá que o arquivo \".js\" é criado automáticamente sempre que o projeto é compilado.1234567891011O JavaScript é uma linguagem sem tipagem e por isso podemos passar para a função &quot;saudacao&quot; um numero ou uma expressão como argumento. Embora tenhamos criado o código para receber uma string com um nome este poderá receber qualquer coisa como argumento. É claro que com uma validação extra conseguimos evitar que argumentos que não sejam do tipo string sejam passados para a função. No entanto vamos utilizar um recurso do TypeScript chamado de &quot;Type anotation&quot; para validar esta passagem de argumento. Altere o código da função &quot;saudacao&quot; como no código abaixo:```javascriptfunction saudacao(pessoa: string)&#123; return &quot;Olá &quot; + pessoa;&#125;var alguem = &quot;Diullei Gomes&quot;;document.body.innerHTML = saudacao(alguem); Agora veja que se tentarmos passar um array como argumento o compilador do TypeScrit irá acusar erro. 1234567function saudacao(pessoa: string)&#123; return \"Olá \" + pessoa;&#125;var alguem = [1, 2, 3, 4];console.log(saudacao(alguem)); O que fizemos foi dizer ao TypeScript que nossa função “saudacao” recebe um argumento do tipo “string”. Node que mesmo tendo o código com erro o TypeScrit irá gerar o arquivo “.js”. O TypeScript sempre irá compilar o arquivo, no entanto sempre que existirem erros ele irá alertar estes erros a fim de informar que alguma coisa poderá não funcionar da forma esperada. Isso é feito para permitir integração com código JavaScript convencional. InterfacesVamos avançar e introduzir o uso de interfaces. Veja o código abaixo: 123456789101112interface Pessoa &#123; primeiroNome: string; ultimoNome: string;&#125;function saudacao(pessoa: Pessoa)&#123; return \"Olá \" + pessoa.primeiroNome + \" \" + pessoa.ultimoNome;&#125;var alguem = &#123; primeiroNome: \"Diullei\", sobreNome: \"Moura\", ultimoNome: \"Gomes\" &#125;;console.log(saudacao(alguem)); No codigo acima criamos uma interface que define dois campos: primeiroNome e ultimoNome. Não vou me aprofundar no conceito de interface mais entenda que interfaces definem contratos. Repare que alteramos a assinatura da função “saudacao” para receber um argumento do tipo “Pessoa”. Agora o compilador do TypeScript irá exigir que o argumento da função obedeça o contrato definido na interface, ou seja, precisamos passar um objeto que possua uma propriedade chamada “primeiroNome” com um valor do tipo string e uma propriedade chamada “ultimoNome” com um valor do tipo string. Veja que o objeto “alguem” que estamos passando também possui uma propriedade chamada “sobreNome” que não interfere de maneira alguma no código já que este objeto obedece a interface. Teríamos um erro se omitíssemos um dos campos exigidos pela interface. ClassesVamos alterar o código acima agora e utilizar o conceito de classes. Veja o código: 123456789101112class Pessoa &#123; primeiroNome: string; ultimoNome: string;&#125;function saudacao(pessoa: Pessoa)&#123; return \"Olá \" + pessoa.primeiroNome + \" \" + pessoa.ultimoNome;&#125;var alguem = &#123; primeiroNome: \"Diullei\", sobreNome: \"Moura\", ultimoNome: \"Gomes\" &#125;;console.log(saudacao(alguem)); Se você tentar executar o código acima vai ter um erro. O erro ocorre por que diferente da interface quando usamos uma classe o objeto esperado pela função tem que seguir exatamente as caracteristicas definidas na classe ou ser um tipo que herde desta classe. Se tirarmos a propriedade sobreNome do objeto “alguem” o código irá compilar sem erro. O que foi apresentado até aqui é bem simples mais introduz bem a intenção do TypeScript. Para saber mais acesse a documentação oficial. Estou trabalhando na tradução desta documentação e logo estarei divulgando o link de acesso. O argumento “declare”Uma caracteristica interessante do TypeScript e a possibilidade de declarar variáveis que não serão geradas no momento da compilação. Isso ajudar a definir objetos que irão existir no ambiente de execução mais que não existem código. Assim não teremos erro de compilação. Um exemplo seria a utilização do jquery “$” em um browser. Ao escrever o código abaixo o TypeScrit irá acusar erro por não termos declarado o objeto “document”. 1$('body').append('teste'); Para evitar que tenhamos erro podemos declarar uma variável “fantasma” que só servirá para garantir a compilação. Esta variável não será gerada pelo compilador e por isso precisamos ter certeza de que neste nosso caso o código será executado em um ambiente no qual o jquery esteja referenciado. Veja o exemplo: 123declare var $: any;$('body').append('teste'); Tiposo TypeScript mantém os tipos nativos do JavaScript: number, string, bool entre outros e introduz um tipo novo chamado any. O tipo any é utilizado para representar um valor JavaScript qualquer. Trata-se de um tipo dinâmico que não é validado pelo compilador do TypeScript, ou seja, se você tentar invocar uma função “xyz()” de um objeto “a” do tipo “any” o compilador não irá verificar se o objeto “a” possui realmente a função “xyz()”. 123var a: any;console.log(a.xyz()); NOTA: qualquer variável declarada sem um tipo definido será automaticamente classificada pelo TypeScript como uma variável do tipo “any”. FunçõesCom TypeScript podemos definir exatamente os argumentos e o retorno de uma função. Veja o código abaixo: 12345var minhaFuncao: (a: number, b: string) =&gt; string;minhaFuncao = function()&#123; return ''; &#125;;minhaFuncao(1, \"arg2\"); Vamos entender o código acima. Usando a notação de tipos do TypeScript definimos uma variável chamada “minhaFuncao” para receber como valor uma função que tenha 2 argumentos um numero e uma string e definimos o retorno desta função para ser do tipo string. Na segunda linda de código foi adicionado o valor “function(){ return ‘’; }” a esta variável. Até aqui não temos nenhum erro de compilação por que não foram definidos os argumentos desta função e o TypeScript irá validar o tipo dos argumentos passados para a função apenas quando esta função for invocada. Tente alterar o valor do retorno da função para um tipo diferente do tipo “string” ou alterar o tipo dos argumentos passados na terceira linha quando invocamos a função e verá que o TypeScript acusará erro. Ele vai tentar sempre garantir que a interface da função definida na primeira linha seja obedecida. Esse recurso de tipagem de funções fornecido pelo TypeScript é muito interessante quando queremos definir o tipo de uma função de “callback” na assinatura de uma função qualquer. Veja abaixo um exemplo de uma função chamada “ajax” que define o tipo do segundo argumento como uma função de “callback” que tenha um argumento de qualquer tipo e retorne um valor do tipo string: 123function ajax(url: string, callback: (data: any) =&gt; string) &#123; //...&#125; ConclusãoApresentei apenas o básico sobre TypeScript. Se você gostou do que viu sugiro a leitura da documentação. Espero que tenham aproveitado o artigo. Até a próxima!","categories":[{"name":"TypeScript","slug":"TypeScript","permalink":"http://diullei.com/categories/TypeScript/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://diullei.com/tags/JavaScript/"},{"name":"TypeScript","slug":"TypeScript","permalink":"http://diullei.com/tags/TypeScript/"}]},{"title":"JavaScript NoConflict","slug":"JavaScript-NoConflict","date":"2012-07-28T22:00:00.000Z","updated":"2019-01-07T23:15:42.327Z","comments":true,"path":"2012/07/29/JavaScript-NoConflict/","link":"","permalink":"http://diullei.com/2012/07/29/JavaScript-NoConflict/","excerpt":"Você já deve ter visto exemplos de código JQuery, Underscore, Backbone ou outros que utilizassem um método chamado noConflict(). Vamos entender para que serve este método. Como o próprio nome já diz este método é colocado na biblioteca para permitir que seu código coexista com outros códigos sem a ocorrência de conflitos. Vamos a um exemplo utilizando duas bibliotecas que utilizam o mesmo nome: 12345678910111213141516171819202122// libA(function(exports)&#123; function LibA()&#123;&#125; LibA.prototype.Execute = function()&#123; console.log('lib A'); &#125; exports.$ = new LibA();&#125;)(window);// libB(function(exports)&#123; function LibB()&#123;&#125; LibB.prototype.Execute = function()&#123; console.log('lib B'); &#125; exports.$ = new LibB();&#125;)(window);$.Execute();//=&gt; lib B","text":"Você já deve ter visto exemplos de código JQuery, Underscore, Backbone ou outros que utilizassem um método chamado noConflict(). Vamos entender para que serve este método. Como o próprio nome já diz este método é colocado na biblioteca para permitir que seu código coexista com outros códigos sem a ocorrência de conflitos. Vamos a um exemplo utilizando duas bibliotecas que utilizam o mesmo nome: 12345678910111213141516171819202122// libA(function(exports)&#123; function LibA()&#123;&#125; LibA.prototype.Execute = function()&#123; console.log('lib A'); &#125; exports.$ = new LibA();&#125;)(window);// libB(function(exports)&#123; function LibB()&#123;&#125; LibB.prototype.Execute = function()&#123; console.log('lib B'); &#125; exports.$ = new LibB();&#125;)(window);$.Execute();//=&gt; lib B Note que no exemplo acima estamos criando duas bibliotecas e dando a elas o mesmo alias $. Quando a libA é criada ela cria uma instância global chamada $. Caso executemos $.Execute() teremos como resultado o texto lib A no console. Mais veja que logo em seguida criamos a libB. A libB também está utilizando o mesmo nome para sua instância global $ fazendo com que a instância da libA seja sobrescrita. Assim quando chamamos $.Execute() temos como resultado o texto lib B. Uma forma elegante de permitir que o problema acima seja contornado é utilizar um método noConflict(). Veja o exemplo reescrito: 1234567891011121314151617181920212223242526272829303132333435363738394041// lib A(function(exports)&#123; var oldLib = exports.$; function LibA()&#123;&#125; LibA.prototype.Execute = function()&#123; console.log('lib A'); &#125; LibA.prototype.noConflict = function()&#123; exports.$ = oldLib; return this; &#125; exports.$ = new LibA();&#125;)(window);// lib B(function(exports)&#123; var oldLib = exports.$; function LibB()&#123;&#125; LibB.prototype.Execute = function()&#123; console.log('lib B'); &#125; LibB.prototype.noConflict = function()&#123; exports.$ = oldLib; return this; &#125; exports.$ = new LibB();&#125;)(window);$libB = $.noConflict();$.Execute();//=&gt; lib A$libB.Execute();//=&gt; lib B Note que no exemplo acima fizemos em libB um ‘backup’ do valor de $ antes de altera-lo. Adicionamos uma função chamada noConflict() com o objetivo de restaurar o antigo valor de $ e retornar a propria libB como resultado. Isso permite a quem estiver utilizando o código renomear a instância de libB. Veja que no código acima alteramos o nome de $ para $libB. Usando este artificio poderíamos também fazer com que 2 ou mais versões de uma mesma biblioteca coexistissem no mesmo código. Seguem algumas referências a trechos de códigos reais que utilizam este padrão: jQuery 123456789101112131415..._$ = window.$,...noConflict: function( deep ) &#123; if ( window.$ === jQuery ) &#123; window.$ = _$; &#125; if ( deep &amp;&amp; window.jQuery === jQuery ) &#123; window.jQuery = _jQuery; &#125; return jQuery;&#125;,... Backbone 12345678...var previousBackbone = root.Backbone;...Backbone.noConflict = function() &#123; root.Backbone = previousBackbone; return this;&#125;;... Underscore 12345678...var previousUnderscore = root._;..._.noConflict = function() &#123; root._ = previousUnderscore; return this; &#125;; ... Esses são só alguns exemplos. Abraços!","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://diullei.com/categories/JavaScript/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://diullei.com/tags/JavaScript/"}]},{"title":"Lendo arquivos com Nodejs","slug":"Lendo-arquivos-com-Nodejs","date":"2012-07-17T22:00:00.000Z","updated":"2019-01-07T23:15:42.327Z","comments":true,"path":"2012/07/18/Lendo-arquivos-com-Nodejs/","link":"","permalink":"http://diullei.com/2012/07/18/Lendo-arquivos-com-Nodejs/","excerpt":"Existem algumas formas diferentes de ler arquivos usando node.js. Existem métodos síncronos e métodos assíncronos que nos permitem realizar este trabalho. Vou exibir e explicar estas diversas formas no decorrer deste post. Vamos ao nosso primeiro exemplo: 12345678910var fs = require('fs');fs.readFile('TEST.txt', function(err,data)&#123; if(err) &#123; console.error(\"Could not open file: %s\", err); process.exit(1); &#125; console.log(data);&#125;); Precisamos primeiro de tudo carregar o módulo fs pois é a partir deste módulo que teremos acesso aos métodos de leitura e escrita de arquivos. Logo em seguida fazemos uma chamada ao método: fs.readFile. Esta função recebe na assinatura o nome do arquivo, um parâmetro opcional que define o encoding que será utilizado durante a leitura do arquivo e um método de callback que será utilizado para manipular os dados lidos do disco. Esse método recebe 2 parâmetros err e data. Sempre que ocorrer um erro durante a leitura do arquivo o parâmetro err virá preenchido com as informações referente ao erro. Se o parametro err vier vazio significa que a leitura do arquivo ocorreu sem problemas e então poderemos manipular o pârametro data que possui o conteúdo do arquivo que está sendo lido. Note que fazemos primeiro a verificação de erros antes de prosseguir com a manipulados dos dados.","text":"Existem algumas formas diferentes de ler arquivos usando node.js. Existem métodos síncronos e métodos assíncronos que nos permitem realizar este trabalho. Vou exibir e explicar estas diversas formas no decorrer deste post. Vamos ao nosso primeiro exemplo: 12345678910var fs = require('fs');fs.readFile('TEST.txt', function(err,data)&#123; if(err) &#123; console.error(\"Could not open file: %s\", err); process.exit(1); &#125; console.log(data);&#125;); Precisamos primeiro de tudo carregar o módulo fs pois é a partir deste módulo que teremos acesso aos métodos de leitura e escrita de arquivos. Logo em seguida fazemos uma chamada ao método: fs.readFile. Esta função recebe na assinatura o nome do arquivo, um parâmetro opcional que define o encoding que será utilizado durante a leitura do arquivo e um método de callback que será utilizado para manipular os dados lidos do disco. Esse método recebe 2 parâmetros err e data. Sempre que ocorrer um erro durante a leitura do arquivo o parâmetro err virá preenchido com as informações referente ao erro. Se o parametro err vier vazio significa que a leitura do arquivo ocorreu sem problemas e então poderemos manipular o pârametro data que possui o conteúdo do arquivo que está sendo lido. Note que fazemos primeiro a verificação de erros antes de prosseguir com a manipulados dos dados. Vamos ver o resultado deste código: Veja que quando escrevemos o conteúdo de data no console vemos muitos números estranhos. Esse conteúdo é totalmente diferente do arquivo que estou tentando ler. A documentação nos passa uma dica do que está ocorrendo: If no encoding is specified, then the raw buffer is returned. Ou seja, se não passarmos um valor para o parâmetro encoding (segundo parâmetro da função readFile) o resultado é retornado da forma em que está gravado no disco. O node nos dá ainda a chance de utilizar o método toString no buffer(variável que contém o resultado da leitura do arquivo) passando como parâmetro o encoding desejado. Vejamos os exemplos abaixo: passando o encoding:12345678910var fs = require('fs');fs.readFile('TEST.txt', 'utf8', function(err,data)&#123; if(err) &#123; console.error(\"Could not open file: %s\", err); process.exit(1); &#125; console.log(data);&#125;); usando o método toString(…) 12345678910var fs = require('fs');fs.readFile('TEST.txt', function(err,data)&#123; if(err) &#123; console.error(\"Could not open file: %s\", err); process.exit(1); &#125; console.log(data.toString('utf8'));&#125;); A decisão sobre o tipo de encoding utilizar vai depender de que manipulação precisaremos realizar com o conteúdo do arquivo que estamos lendo. Se queremos enviar este conteúdo pela rede para um cliente manter o buffer do jeito que está armazenado no disco é a melhor escolha. Desse jeito podemos utilizar a propriedade length para para pegar o tamanho do arquivo em bytes por exemplo. Isso é muito útil quando queremos por exemplo enviar o tamanho do nosso arquivo no Content-Length no cabeçalho HTTP. Se o que queremos fazer é manipulação de strings a melhor escolha é passar um encoding. Um ponto importante a se notar é que da forma em que estamos lendo o arquivo temos os dados do arquivo todo armazenado em memória. Em algum momento o garbage collector irá decidir por remover estes dados da memória caso não exista mais nenhuma referência para o mesmo. Outro ponto é que esta operação é uma operação assíncrona. Vamos ver agora uma implementação síncrona de leitura de arquivos utilizando o método fs.readFileSync. Este método bloqueia o bloco de código e não permite que o código avance sem que a leitura do arquivo seja finalizada. Segue um exemplo: 12345678910var fs = require('fs');try &#123; var data = fs.readFileSync('TEST.txt', 'ascii'); console.log(data);&#125;catch (err) &#123; console.error(\"There was an error opening the file:\"); console.log(err);&#125; Aqui podemos destacar duas grandes diferenças. A primeiro é que não temos mais o nosso método de callback. Não precisamos mais dele já que a execução da leitura será realizada de forma síncrona. A outra diferença é que precisamos gerenciar as exeções por nós mesmo, por isso colocamos o código dentro de um bloco try…catch. Até agora vimos métodos de leitura que funcionam muito bem para leitura de arquivos de tamanho razoável. Como todos os dados do arquivo são armazenados por completo na memória se quiséssemos ler um arquivo com alguns gigas de tamanho por exemplo teríamos alguns sérios problemas. Para essa situação de leitura de arquivos maiores iremos utilizar o método fs.createReadStream. Com esse método podemos ler o arquivo definindo um tamanho de memória máximo a ser utilizado. As opções de configuração para utilização deste método são: 1234567&#123; flags: 'r', encoding: null, fd: null, mode: 0666, bufferSize: 64 * 1024&#125; Os atributos principais nos quais devemos nos concentrar é o encoding e o bufferSize. Com o atributo bufferSize dizemos o volume de dados que será lido por vez. O valor padrão como exibido acima é 64 kb. Como esse método é assíncrono nós iremos manipular o resultado monitorando alguns eventos específicos. Vamos a um exemplo: 123456789101112var fs = require('fs');var read_stream = fs.createReadStream('TEST.txt', &#123;encoding: 'ascii'&#125;);read_stream.on(\"data\", function(data)&#123; process.stdout.write(data);&#125;);read_stream.on(\"error\", function(err)&#123; console.error(\"An error occurred: %s\", err)&#125;);read_stream.on(\"close\", function()&#123; console.log(\"File closed.\")&#125;); Repare que temos 3 eventos. data que é chamado cada vez que um trecho do arquivo com o tamanho definido no bufferSize for carregado em memória, error que é chamado sempre que um erro ocorrer durante a leitura e close que será chamado quando a leitura for finalizada. Aqui vale notar que trabalhamos com o arquivo pedaço por pedaço e por isso não usamos console.log(…) para não colocar uma quebra de linha a cada leitura de trecho do arquivo. Usamos no lugar o método process.stdout.write para que a cada final e trecho de leitura não tenhamos nenhum caracter de quebra de linha inserido alterando o conteúdo do nosso arquivo. Hoje ficamos por aqui. Um abraço pra todos!","categories":[{"name":"NodeJs","slug":"NodeJs","permalink":"http://diullei.com/categories/NodeJs/"}],"tags":[{"name":"NodeJs","slug":"NodeJs","permalink":"http://diullei.com/tags/NodeJs/"}]},{"title":"Configurando o Nodejs com o Notepad++","slug":"Configurando-o-NodeJs-com-o-Npp","date":"2012-07-16T22:00:00.000Z","updated":"2019-01-07T23:15:42.327Z","comments":true,"path":"2012/07/17/Configurando-o-NodeJs-com-o-Npp/","link":"","permalink":"http://diullei.com/2012/07/17/Configurando-o-NodeJs-com-o-Npp/","excerpt":"O note pad++ é na minha opinião um excelente editor. É claro, com o Sublime Text 2 na área muita gente deixou de olhar para p Np++ :). Minha dica de hoje é mostrar como configurar o Np++ para executar arquivos javascript usando o nodeJs. ###NodeJs Caso você não possua o nodejs instalado na sua máquina vá até o site http://www.nodejs.org/ e faça o download. A instalação é bem simples e você encontra no site toda orientação necessária. ###Configurando o NotePad++ com o NodeJs Primeiro de tudo será necessário instalalar o plugin NppExec. Vá até o menu Plugins-&gt;Plugin Manager-&gt;Show Plugin Manager. Na aba Avaliable selecione NppExec e clique em install. Feito isso reinicie o npp++. Feito isso vamos configurar o NppExec. Acesse o menu Plugins-&gt;NppExec e selecione Follow $(CURRENT_DIRECTORY).","text":"O note pad++ é na minha opinião um excelente editor. É claro, com o Sublime Text 2 na área muita gente deixou de olhar para p Np++ :). Minha dica de hoje é mostrar como configurar o Np++ para executar arquivos javascript usando o nodeJs. ###NodeJs Caso você não possua o nodejs instalado na sua máquina vá até o site http://www.nodejs.org/ e faça o download. A instalação é bem simples e você encontra no site toda orientação necessária. ###Configurando o NotePad++ com o NodeJs Primeiro de tudo será necessário instalalar o plugin NppExec. Vá até o menu Plugins-&gt;Plugin Manager-&gt;Show Plugin Manager. Na aba Avaliable selecione NppExec e clique em install. Feito isso reinicie o npp++. Feito isso vamos configurar o NppExec. Acesse o menu Plugins-&gt;NppExec e selecione Follow $(CURRENT_DIRECTORY). Em seguida acesse o menu PLugins-&gt;NppExec-&gt;Execute…. Na janela que vai aparecer digite: 12cd \"$(CURRENT_DIRECTORY)\"node $(FILE_NAME) Clique no botão Save e na janela que se abre de o nome “Run” e clique em Save. Em seguida basta dar ok. Agora vamos configurar um atalho. Vá no menu Plugins-&gt;NppExec-&gt;Advanced Options Selecione o checkbox Place to the Macros submenu. Selecione Run na combo Associated script e dê o nome Run Nodejs no campo Item name. Em seguida clique no botão Add/Modify button. Clique no botão Ok e reinicie o Np++. Vá no menu Settings-&gt;Short Mapper… Selecione Plugin commands e localize Run NodeJs na lista de nomes. Clique no botão Modify e e configure a janela seguinte conforme a imagem abaixo: Clique em Ok e pronto! Note que no menu Macro irá aparecer o atalho que acabamos de criar. ##Testando Crie um novo arquivo e escreva o seguinte código: 1console.log('np++ test!!!'); Salve o arquivo e tecle o atalho Ctrl+F5. Se tudo tiver sido configurado corretamente você terá algo como na imagem abaixo: OBS.: O arquivo precisa estar salvo para você conseguir executa-lo. Espero que esta dica seja útil. Até!","categories":[{"name":"NodeJs","slug":"NodeJs","permalink":"http://diullei.com/categories/NodeJs/"}],"tags":[{"name":"NodeJs","slug":"NodeJs","permalink":"http://diullei.com/tags/NodeJs/"},{"name":"Notepad++","slug":"Notepad","permalink":"http://diullei.com/tags/Notepad/"}]}]}