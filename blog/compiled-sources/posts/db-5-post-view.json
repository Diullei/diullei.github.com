{"id":"5","title":"JavaScript - NoConflict","by":"Diullei Gomes","tags":["JavaScript","Pattern"],"category":"JavaScript","date":"'2012-07-29'","deploy":"true","content":"Você já deve ter visto exemplos de código *JQuery*, *Underscore*, *Backbone* ou outros que utilizassem um método chamado ```noConflict()```. Vamos entender para que serve este método.\r\n\r\nComo o próprio nome já diz este método é colocado na biblioteca para permitir que seu código coexista com outros códigos sem a ocorrência de conflitos. \r\n\r\nVamos a um exemplo utilizando duas bibliotecas que utilizam o mesmo nome:\r\n\r\n<pre><code>// libA\r\n(function(exports){\r\n\tfunction LibA(){}\r\n\tLibA.prototype.Execute = function(){\r\n\t\tconsole.log('lib A');\r\n\t}\r\n\t\r\n\texports.$ = new LibA();\r\n})(window);\r\n\r\n// libB\r\n(function(exports){\r\n\tfunction LibB(){}\r\n\tLibB.prototype.Execute = function(){\r\n\t\tconsole.log('lib B');\r\n\t}\r\n\t\r\n\texports.$ = new LibB();\r\n})(window);\r\n\r\n$.Execute();\r\n//=> lib B\r\n</code></pre>\r\n\r\nNote que no exemplo acima estamos criando duas bibliotecas e dando a elas o mesmo alias '$'. Quando a libA é criada ela cria uma instância global chamada $. Caso executemos $.Execute() teremos como resultado o texto 'lib A' no console. Mais veja que logo em seguida criamos a libB. A libB também está utilizando o mesmo nome para sua instância global '$' fazendo com que a instância da libA seja sobrescrita. Assim quando chamamos $.Execute() temos como resultado o texto 'lib B'.\r\n\r\nUma forma elegante de permitir que o problema acima seja contornado é utilizar um método ```noConflict()```. Veja o exemplo reescrito:\r\n\r\n<pre><code>// lib A\r\n(function(exports){\r\n\tvar oldLib = exports.$;\r\n\t\r\n\tfunction LibA(){}\r\n\tLibA.prototype.Execute = function(){\r\n\t\tconsole.log('lib A');\r\n\t}\r\n\r\n\tLibA.prototype.noConflict = function(){\r\n\t\texports.$ = oldLib;\r\n\t\treturn this;\r\n\t}\r\n\t\r\n\texports.$ = new LibA();\r\n})(window);\r\n\r\n// lib B\r\n(function(exports){\r\n\tvar oldLib = exports.$;\r\n\r\n\tfunction LibB(){}\r\n\tLibB.prototype.Execute = function(){\r\n\t\tconsole.log('lib B');\r\n\t}\r\n\t\r\n\tLibB.prototype.noConflict = function(){\r\n\t\texports.$ = oldLib;\r\n\t\treturn this;\r\n\t}\r\n\t\r\n\texports.$ = new LibB();\r\n})(window);\r\n\r\n$libB = $.noConflict();\r\n\r\n$.Execute();\r\n//=> lib A\r\n\r\n$libB.Execute();\r\n//=> lib B\r\n</code></pre>\r\n\r\nNote que no exemplo acima fizemos em libB um 'backup' do valor de '$' antes de altera-lo. Adicionamos uma função chamada ```noConflict()``` com o objetivo de restaurar o antigo valor de '$' e retornar a propria libB como resultado. Isso permite a quem estiver utilizando o código renomear a instância de libB. Veja que no código acima alteramos o nome de $ para $libB.\r\n\r\nUsando este artificio poderíamos também fazer com que 2 ou mais versões de uma mesma biblioteca coexistissem no mesmo código.\r\n\r\nSeguem algumas referências a trechos de códigos reais que utilizam este padrão:\r\n\r\n**jQuery**\r\n<pre><code>...\r\n_$ = window.$,\r\n...\r\nnoConflict: function( deep ) {\r\n\tif ( window.$ === jQuery ) {\r\n\t\twindow.$ = _$;\r\n\t}\r\n\r\n\tif ( deep && window.jQuery === jQuery ) {\r\n\t\twindow.jQuery = _jQuery;\r\n\t}\r\n\r\n\treturn jQuery;\r\n},\r\n...</code></pre>\r\n\r\n**Backbone**\r\n<pre><code>...\r\nvar previousBackbone = root.Backbone;\r\n...\r\nBackbone.noConflict = function() {\r\n    root.Backbone = previousBackbone;\r\n    return this;\r\n};\r\n...</code></pre>\r\n\r\n**Underscore**\r\n<pre><code>...\r\nvar previousUnderscore = root._;\r\n...\r\n_.noConflict = function() {\r\n    root._ = previousUnderscore;\r\n    return this;\r\n  };\r\n  ...</code></pre>\r\n  \r\nEsses são só alguns exemplos.\r\n\r\nAbraços!\n","ref":"no_conflict_pattern.post.mkdown"}