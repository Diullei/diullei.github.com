<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Diullei</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://diullei.com/"/>
  <updated>2019-01-07T23:15:42.331Z</updated>
  <id>http://diullei.com/</id>
  
  <author>
    <name>Diullei Gomes</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Operador keyof</title>
    <link href="http://diullei.com/2017/03/31/keyof/"/>
    <id>http://diullei.com/2017/03/31/keyof/</id>
    <published>2017-03-31T06:32:56.000Z</published>
    <updated>2019-01-07T23:15:42.331Z</updated>
    
    <content type="html"><![CDATA[<p>Por ser uma linguagem dinâmica, o JavaScript algumas vezes torna difícil a representação de algumas operações em um sistema tipado. Por exemplo, vejamos a seguinte função:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">prop</span>(<span class="params">obj, propertyName</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> obj[propertyName];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Essa função aceita um objeto e um nome de propriedade e retorna o valor correspondente desta propriedade. É importante observar que diferentes propriedades em um objeto possuem diferentes tipos. Com isso em mente, como podemos definir o tipo de retorno desta função?</p><p>Vamos a uma primeira tentativa:</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">prop</span>(<span class="params">obj: &#123;&#125;, propertyName: <span class="built_in">string</span></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> obj[propertyName];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Adicionamos 2 anotações <code>obj: {}, propertyName: string</code>. Com isso estamos dizendo que <code>obj</code> precisa ser um objeto e que <code>propertyName</code> precisa ser do tipo string. </p><p>Agora como definir o tipo de retorno desta função?</p><a id="more"></a><p>Vamos a um exemplo prático:</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">prop</span>(<span class="params">obj: &#123;&#125;, propertyName: <span class="built_in">string</span></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> obj[propertyName];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> myObj = &#123;</span><br><span class="line">    strProp: <span class="string">'str value'</span>,</span><br><span class="line">    boolProp: <span class="literal">true</span>,</span><br><span class="line">    numberProp: <span class="number">100</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> val1 = prop(myObj, <span class="string">'strProp'</span>); <span class="comment">// tipo de retorno 'any'</span></span><br><span class="line"><span class="keyword">const</span> val2 = prop(myObj, <span class="string">'boolProp'</span>); <span class="comment">// tipo de retorno 'any'</span></span><br><span class="line"><span class="keyword">const</span> val3 = prop(myObj, <span class="string">'numberProp'</span>); <span class="comment">// tipo de retorno 'any'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> val4 = prop(myObj, <span class="string">'xyz'</span>); <span class="comment">// irá falhar em tempo de execução. </span></span><br><span class="line">                                 <span class="comment">// xyz não é uma propriedade válida neste objeto</span></span><br></pre></td></tr></table></figure><p>Para qualquer propriedade existente que pasemos o retorno será inferido como sendo do tipo <code>any</code>. Para o caso de passar uma propriedade inexistente teremos um erro em tempo de execução.</p><p>Isso ocorre por que neste caso o compilador do TypeScript não consegue prever de antemão quais possíveis objetos serão passados como argumento para <code>prop(...)</code> e com isso não é possível inferir o tipo de retorno.</p><p>Para fazer com que o compilador reconheça o tipo de <code>obj</code> poderíamos ajustar o código da seguinte forma:</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">prop</span>&lt;<span class="title">T</span>&gt;(<span class="params">obj: T, propertyName: <span class="built_in">string</span></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> obj[propertyName];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Note que estamos utilizando um tipo genérico que será inferido no momento em que um objeto for passado em <code>obj</code>. Mesmo com esse ajuste, seguimos não alcançando o resultado esperado. Embora agora o compilador entenda o tipo de <code>obj</code> ele continua não sabendo se <code>propertyName</code> realmente existe em <code>obj</code> e, caso exista, qual o seu tipo.</p><p>Ok, vamos supor agora em um outro exemplo que sabemos de antemão o tipo exato que será passado para a função <code>prop(...)</code>. Suponha que tenhamos uma interface com a seguinte estrutura:</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> MyInterface &#123;</span><br><span class="line">    id: <span class="built_in">number</span>;</span><br><span class="line">    text: <span class="built_in">string</span>;</span><br><span class="line">    due: <span class="built_in">Date</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>Para entender melhor o próximo exemplo de código precisamos relembrar outras duas funcionalidades importantes:</p><ul><li><strong>Union types</strong> - Permite informar se um objeto pode ser um ou mais tipos diferentes. <a href="/2016/07/13/union-types/">Veja mais</a>.</li><li><strong>String literal</strong> - Permite definir quais valores um objeto do tipo string pode assumir. <a href="https://github.com/Microsoft/TypeScript/pull/5185" target="_blank" rel="noopener">Veja mais</a>.</li></ul></blockquote><p>Vamos reescrever a função da seguinte forma:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">prop</span>(<span class="params">obj: MyInterface, propertyName: <span class="string">"id"</span> | <span class="string">"text"</span> | <span class="string">"due"</span></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> obj[propertyName];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Vejamos o que temos até agora. Com essa mudança tentarmos passar uma propriedade que não existe na interface <code>MyInterface</code>, ou seja, que não esteja no tipo <code>&quot;id&quot; | &quot;text&quot; | &quot;due&quot;</code>, teremos um erro em tempo de compilação.</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> val4 = prop(myObj, <span class="string">'xyz'</span>); <span class="comment">// erro! 'xyz' não pertende ao tipo "id" | "text" | "due"</span></span><br></pre></td></tr></table></figure><p>Isso é bom, resolve parte do problema, mas também nos gera um novo problema. Agora estamos protegendo o valor de <code>propertyName</code> definindo o que realmente pode ser passado mas continuamos não tendo como prever o tipo de <code>obj</code> e as possíveis propriedades de <code>obj</code> em <code>propertyName</code>. Nessa função precisa ser genérica, ou seja, funcionar em todos os casos e não somente para o tipo <code>MyInterface</code>.</p><h2 id="Solucao"><a href="#Solucao" class="headerlink" title="Solução"></a>Solução</h2><p>Para resolver este tipo de problema foi acrescentado na versão 2.1 do TypeScript o operador <code>keyof</code>. O objetivo deste operador é retornar um “union type” de “string literals” representando o nome de cada propriedade do tipo em que estamos aplicando o <code>keyof</code>. Confuso não? </p><p>Vamos a um exemplo para entender melhor. Utilizando a mesma interface do exemplo anterior, podemos utilizar o operador <code>keyof</code> para retornar um tipo que represente um “union type” de “string literals” com a combinação dos nomes das propriedades de <code>MyInterface</code>:</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> MyInterfaceKeys = keyof MyInterface;  <span class="comment">// "id" | "text" | "due"</span></span><br></pre></td></tr></table></figure><p>Isso equivale ao mesmo que escrever:</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> MyInterfaceKeys = <span class="string">"id"</span> | <span class="string">"text"</span> | <span class="string">"due"</span>;</span><br></pre></td></tr></table></figure><p>Mas em alguns casos precisamos que isso seja feito de forma dinâmica sendo recuperado direto de uma dada interface e por isso nesses casos utilizaremos o <code>keyof</code>.</p><p>Com base no que acabou de ser apresentado, vamos alterar a função <code>prop(...)</code> da seguinte forma:</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">prop</span>&lt;<span class="title">T</span>, <span class="title">K</span> <span class="title">extends</span> (<span class="params">keyof T</span>)&gt;(<span class="params">obj: T, propertyName: K</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> obj[propertyName];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>OK, vamos entender as modificações parte a parte:</p><ul><li>Como demonstrado em um exemplo anterior, estamos utilizando um tipo genérico (<code>T</code>) para inferir o tipo de <code>obj</code> em tempo de compilação.</li><li>Baseado também em exemplos anteriores, estamos utilizando <code>keyof T</code> para recuperar um tipo que represente os possíveis nomes de propriedades de <code>T</code> (repare que estamos colocando <code>keyof</code> entre parêntesis no exemplo só pra facilitar a leitura, no entanto esses parêntesis não são necessários).</li><li>Estamos definindo um outro tipo genérico <code>K</code> para extender o tipo gerado por <code>keyof T</code>.</li></ul><p>Com base nessas informações, agora o compilador consegue inferir que o retorno de <code>prop(...)</code> é <code>T[K]</code>, e outras palavras, é o tipo resultante da aplicação da propriedade <code>K</code> no objeto <code>T</code>, e com isso agora temos o retorno da função inferido da forma correta correspondente ao tipo da propriedade solicitada.</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">prop</span>&lt;<span class="title">T</span>, <span class="title">K</span> <span class="title">extends</span> (<span class="params">keyof T</span>)&gt;(<span class="params">obj: T, propertyName: K</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> obj[propertyName];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> myObj = &#123;</span><br><span class="line">    strProp: <span class="string">'str value'</span>,</span><br><span class="line">    boolProp: <span class="literal">true</span>,</span><br><span class="line">    numberProp: <span class="number">100</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> val1 = prop(myObj, <span class="string">'strProp'</span>); <span class="comment">// retorna 'string'</span></span><br><span class="line"><span class="keyword">const</span> val2 = prop(myObj, <span class="string">'boolProp'</span>); <span class="comment">// retorna 'boolean'</span></span><br><span class="line"><span class="keyword">const</span> val3 = prop(myObj, <span class="string">'numberProp'</span>); <span class="comment">// retorna 'number'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> val4 = prop(myObj, <span class="string">'xyz'</span>); <span class="comment">// irá falhar em tempo de compilação. </span></span><br><span class="line">                                 <span class="comment">// Argument of type '"xyz"' is not assignable to </span></span><br><span class="line">                                 <span class="comment">// parameter of type '"strProp" | "boolProp" | "numberProp"'.</span></span><br></pre></td></tr></table></figure><p>Excelente não? Isso nos ajuda a prevenir uma série de erros. Esta é só uma das formas de aplcação deste operador. Um bom exemplo pode ser encontrado no arquivo <code>lib.es2017.object.d.ts</code> que é instalado junto com o compilador do TypeScript:</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> ObjectConstructor &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    entries&lt;T <span class="keyword">extends</span> &#123; [key: <span class="built_in">string</span>]: <span class="built_in">any</span> &#125;, K <span class="keyword">extends</span> keyof T&gt;(o: T): [keyof T, T[K]][];</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Essa interface é utilizada para definir o tipo da função <a href="https://developer.mozilla.org/pt-BR/docs/Web/JavaScript/Reference/Global_Objects/Object/entries" target="_blank" rel="noopener"><code>Object.entries()</code></a>, onde o retorno é um array com de pares de valores contendo <code>[propertyName, value]</code> para um dado objeto.</p><blockquote><p>Reference: TS v2.1 <a href="https://github.com/Microsoft/TypeScript/pull/11929" target="_blank" rel="noopener">https://github.com/Microsoft/TypeScript/pull/11929</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Por ser uma linguagem dinâmica, o JavaScript algumas vezes torna difícil a representação de algumas operações em um sistema tipado. Por exemplo, vejamos a seguinte função:&lt;/p&gt;
&lt;figure class=&quot;highlight javascript&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;prop&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;obj, propertyName&lt;/span&gt;) &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; obj[propertyName];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;Essa função aceita um objeto e um nome de propriedade e retorna o valor correspondente desta propriedade. É importante observar que diferentes propriedades em um objeto possuem diferentes tipos. Com isso em mente, como podemos definir o tipo de retorno desta função?&lt;/p&gt;
&lt;p&gt;Vamos a uma primeira tentativa:&lt;/p&gt;
&lt;figure class=&quot;highlight typescript&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;prop&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;obj: &amp;#123;&amp;#125;, propertyName: &lt;span class=&quot;built_in&quot;&gt;string&lt;/span&gt;&lt;/span&gt;) &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; obj[propertyName];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;Adicionamos 2 anotações &lt;code&gt;obj: {}, propertyName: string&lt;/code&gt;. Com isso estamos dizendo que &lt;code&gt;obj&lt;/code&gt; precisa ser um objeto e que &lt;code&gt;propertyName&lt;/code&gt; precisa ser do tipo string. &lt;/p&gt;
&lt;p&gt;Agora como definir o tipo de retorno desta função?&lt;/p&gt;
    
    </summary>
    
      <category term="TypeScript" scheme="http://diullei.com/categories/TypeScript/"/>
    
      <category term="TypeScript v2.1" scheme="http://diullei.com/categories/TypeScript/TypeScript-v2-1/"/>
    
    
      <category term="JavaScript" scheme="http://diullei.com/tags/JavaScript/"/>
    
      <category term="TypeScript" scheme="http://diullei.com/tags/TypeScript/"/>
    
  </entry>
  
  <entry>
    <title>TypeScript - Decorators</title>
    <link href="http://diullei.com/2016/11/21/Decorators-TypeScript/"/>
    <id>http://diullei.com/2016/11/21/Decorators-TypeScript/</id>
    <published>2016-11-20T23:00:00.000Z</published>
    <updated>2019-01-07T23:15:42.331Z</updated>
    
    <content type="html"><![CDATA[<p>Fala pessoal! Hoje vou falar sobre uma feature muito legal <code>decorators</code>. Utilizamos decorators para inserir metadados e comportamentos em uma declaração de classe, propriedade, métodos ou parâmetro de uma função. Trata-se de uma função com uma assunatura específica (de acordo com o <code>target</code>).</p><p>Para utilizar um decorator precisamos utilizar o simbolo <code>@</code> junto com o nome do decorator antes do membro do código que estivermos decorando. Exemplo:</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> MyClass &#123;</span><br><span class="line">    <span class="meta">@log</span></span><br><span class="line">    doSomething(arg) &#123;</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>NOTA: para utilizar esse recurso é necessário configurar a propriedade <code>experimentalDecorators</code> no arquivo <code>tsconfig.json</code>. Para compilar o arquivo via linha de comando utilize: <code>tsc myFile.ts –target ES5  –emitDecoratorMetadata</code>.</p></blockquote><a id="more"></a><h2 id="Pontos-importantes"><a href="#Pontos-importantes" class="headerlink" title="Pontos importantes"></a>Pontos importantes</h2><ul><li><p>Os decorators são sempre chamados quando uma classe é declarada e não quando um objeto é instanciado.</p></li><li><p>Multiplos decorators podem ser declarados para um mesmo target.</p></li><li><p>não é permitida a utilização de decorators em construtores.</p></li><li><p>Os decorators podem ser do tipo: <code>ClassDecorator</code>, <code>PropertyDecorator</code>, <code>MethodDecorator</code> ou <code>ParameterDecorator</code>.</p></li></ul><h2 id="Decorators-em-Metodos"><a href="#Decorators-em-Metodos" class="headerlink" title="Decorators em Métodos"></a>Decorators em Métodos</h2><p>Para definir um decorator para um méroto precisamos criar uma função com os seguintes parâmetros:</p><ul><li><p><code>target</code> - Protótipo da classe que possui o método.</p></li><li><p><code>propertyKey</code> - Nome do método em que estamos aplicando o decorator. Pode ser um <code>string</code> ou um <a href="https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Symbol" target="_blank" rel="noopener"><code>Symbol</code></a></p></li><li><p><code>descriptor</code> - Uma instância da insterface <a href="https://github.com/Microsoft/TypeScript/blob/727b9a9ceb37c77ba5b69c452cc118a8913d9cf2/src/lib/core.d.ts#L1241" target="_blank" rel="noopener"><code>TypedPropertyDescriptor</code></a></p></li></ul><p>No primeiro exemplo eu utilizei um decorator chamado <code>@log</code>. Vamos ver uma possível implementação deste decorator:</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">log</span>(<span class="params">target: <span class="built_in">Object</span>, propertyKey: <span class="built_in">string</span>, descriptor: TypedPropertyDescriptor&lt;<span class="built_in">any</span>&gt;</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> originalMethod = descriptor.value; <span class="comment">// salvando uma referência para o método original</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// <span class="doctag">NOTE:</span> não use arrou fynction. Utilize uma declaração normal de função para que o contexto `this` seja interpretado corretamente.</span></span><br><span class="line">    descriptor.value = <span class="function"><span class="keyword">function</span>(<span class="params">...args: <span class="built_in">any</span>[]</span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">"Argumentos da chamada: "</span> + <span class="built_in">JSON</span>.stringify(args));</span><br><span class="line">        <span class="keyword">let</span> result = originalMethod.apply(<span class="keyword">this</span>, args);               <span class="comment">// Executa a função e armazena o resultado</span></span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">"Valor de retorno: "</span> + result);               </span><br><span class="line">        <span class="keyword">return</span> result;                                               <span class="comment">// retorna o resultado</span></span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> descriptor;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Chamando a função:</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> MyClass &#123;</span><br><span class="line">    <span class="meta">@log</span></span><br><span class="line">    doSomething(arg) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Message -- "</span> + arg;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> MyClass().doSomething(<span class="string">"test"</span>);</span><br><span class="line"><span class="comment">// =&gt; Argumentos da chamada: ["test"]</span></span><br><span class="line"><span class="comment">// =&gt; Valor de retorno: Message -- test</span></span><br></pre></td></tr></table></figure><p>Agora que vimos como uma declaração simples de decorator funciona vamos entender como declarar decorators que esperam parâmetros. Para isso precisamos declarar uma função com a assinatura de parâmetros desejado e retornar uma outra função com a mesma assinatura do exemplo anterior. Veja o seguinte código:</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">log</span>(<span class="params">showArgs: <span class="built_in">boolean</span></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">target: <span class="built_in">Object</span>, propertyKey: <span class="built_in">string</span>, descriptor: TypedPropertyDescriptor&lt;<span class="built_in">any</span>&gt;</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">let</span> originalMethod = descriptor.value; <span class="comment">// salvando uma referência para o método original</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// <span class="doctag">NOTE:</span> não use arrou fynction. Utilize uma declaração normal de função para que o contexto `this` seja interpretado corretamente.</span></span><br><span class="line">        descriptor.value = <span class="function"><span class="keyword">function</span>(<span class="params">...args: <span class="built_in">any</span>[]</span>) </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (showArgs) &#123;</span><br><span class="line">                <span class="built_in">console</span>.log(<span class="string">"Argumentos da chamada: "</span> + <span class="built_in">JSON</span>.stringify(args));</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">let</span> result = originalMethod.apply(<span class="keyword">this</span>, args);               <span class="comment">// Executa a função e armazena o resultado</span></span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">"Valor de retorno: "</span> + result);               </span><br><span class="line">            <span class="keyword">return</span> result;                                               <span class="comment">// retorna o resultado</span></span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> descriptor;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Mais uma vez vamos chamar a função:</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> MyClass &#123;</span><br><span class="line">    <span class="meta">@log</span>(<span class="literal">false</span>)</span><br><span class="line">    doSomething(arg) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Message -- "</span> + arg;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> MyClass().doSomething(<span class="string">"test"</span>);</span><br><span class="line"><span class="comment">// =&gt; Valor de retorno: Message -- test</span></span><br></pre></td></tr></table></figure><blockquote><p>NOTA: sempre que utilizarmos uma decorator em uma função estática o target será a propria função ou invés do protótipo da classe.</p></blockquote><h2 id="Decorators-em-Classes"><a href="#Decorators-em-Classes" class="headerlink" title="Decorators em Classes"></a>Decorators em Classes</h2><p>A assinatura da função que define um decorator para uma classe possui apenas o parâmetro <code>target</code>. Veja o seguinte exemplo:</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> __myClassDecoratorMetaData: <span class="built_in">any</span> = &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">MyClassDecorator</span>(<span class="params">value: <span class="built_in">string</span></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params">target: <span class="built_in">Function</span></span>) </span>&#123;</span><br><span class="line">      __myClassDecoratorMetaData[target] = value;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@MyClassDecorator</span>(“my metadata”)</span><br><span class="line"><span class="keyword">class</span> MyClass &#123; &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> myClass = <span class="keyword">new</span> MyClass();</span><br><span class="line"><span class="keyword">let</span> value: <span class="built_in">string</span> = __myClassDecoratorMetaData[myClass.constructor];</span><br><span class="line"><span class="built_in">console</span>.log(value); <span class="comment">//=&gt; my metadata</span></span><br></pre></td></tr></table></figure><p>Existe ainda a possibilidade de adicionar decorators em propriedades e argumentos de função. Tentarei cobrir estas outras duas possibilidades em outro artigo.</p><p>Até a próxima!</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Fala pessoal! Hoje vou falar sobre uma feature muito legal &lt;code&gt;decorators&lt;/code&gt;. Utilizamos decorators para inserir metadados e comportamentos em uma declaração de classe, propriedade, métodos ou parâmetro de uma função. Trata-se de uma função com uma assunatura específica (de acordo com o &lt;code&gt;target&lt;/code&gt;).&lt;/p&gt;
&lt;p&gt;Para utilizar um decorator precisamos utilizar o simbolo &lt;code&gt;@&lt;/code&gt; junto com o nome do decorator antes do membro do código que estivermos decorando. Exemplo:&lt;/p&gt;
&lt;figure class=&quot;highlight typescript&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; MyClass &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;meta&quot;&gt;@log&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    doSomething(arg) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;comment&quot;&gt;//...&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;blockquote&gt;
&lt;p&gt;NOTA: para utilizar esse recurso é necessário configurar a propriedade &lt;code&gt;experimentalDecorators&lt;/code&gt; no arquivo &lt;code&gt;tsconfig.json&lt;/code&gt;. Para compilar o arquivo via linha de comando utilize: &lt;code&gt;tsc myFile.ts –target ES5  –emitDecoratorMetadata&lt;/code&gt;.&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="TypeScript" scheme="http://diullei.com/categories/TypeScript/"/>
    
      <category term="TypeScript v1.5" scheme="http://diullei.com/categories/TypeScript/TypeScript-v1-5/"/>
    
    
      <category term="JavaScript" scheme="http://diullei.com/tags/JavaScript/"/>
    
      <category term="TypeScript" scheme="http://diullei.com/tags/TypeScript/"/>
    
  </entry>
  
  <entry>
    <title>jQuery - 10 dicas de performance</title>
    <link href="http://diullei.com/2016/11/01/jQuery-10-dicas-de-performance/"/>
    <id>http://diullei.com/2016/11/01/jQuery-10-dicas-de-performance/</id>
    <published>2016-10-31T23:00:00.000Z</published>
    <updated>2019-01-07T23:15:42.335Z</updated>
    
    <content type="html"><![CDATA[<p>Os anos se passaram e o jQuery continua relevante em pleno 2016. A facilidade de manipulação e a infinidade de artigos na internet ajuda a reforçar a utilização do jQuery e a manter essa biblioteca viva. De fato, poucos anos atrás, escrever codigo compatível com diferentes versões de navegadores seria um trabalho muito árduo se não fosse pelo nosso amigo jQuery.</p><p>O grande problema com o jQuery é que muitos desenvolvedores ignoram as boas práticas e escrevem codigo muito pobres em performance (isso sem falar sobre design de código).</p><h2 id="Por-que-performance-e-importante"><a href="#Por-que-performance-e-importante" class="headerlink" title="Por que performance é importante?"></a>Por que performance é importante?</h2><p>Vou expor duas boas razões:</p><ul><li>Uma boa performance pode trazer uma boa experiência de uso. Nem sempre seus visitanes vão lhe dizer que seu site está lento, eles simplesmente não vão voltar a acessar o site.</li><li>O Google leva a performance em consideração para a classificação do seu site no PageRank.</li></ul><p>Então, vamos aos pontos…</p><a id="more"></a><h2 id="1-Use-a-versao-mais-atual-do-jQuery-sempre-que-possivel"><a href="#1-Use-a-versao-mais-atual-do-jQuery-sempre-que-possivel" class="headerlink" title="1. Use a versão mais atual do jQuery sempre que possível"></a>1. Use a versão mais atual do jQuery sempre que possível</h2><p>As novas versões sempre trazem melhorias de performance e atualizações de segurança.</p><h2 id="2-Utilize-os-seletores-da-forma-correta"><a href="#2-Utilize-os-seletores-da-forma-correta" class="headerlink" title="2. Utilize os seletores da forma correta"></a>2. Utilize os seletores da forma correta</h2><p>Cada seletor possui uma performance diferente. Organizando do mais rápido para o mais lento temos:</p><ul><li>Seleção por ID - <code>$(&#39;#element-id&#39;)</code></li><li>Seleção por Elemento - <code>$(&#39;form&#39;)</code></li><li>Seleção por Classe - <code>$(&#39;.some-class&#39;)</code></li><li>Seleção por Pseudo Atributo - <code>$(&#39;[data-attr]&#39;), $(&#39;:hidden&#39;)</code></li></ul><h2 id="3-O-algoritmo-de-selecao-do-jQuery-funciona-da-esquerda-para-a-direita"><a href="#3-O-algoritmo-de-selecao-do-jQuery-funciona-da-esquerda-para-a-direita" class="headerlink" title="3. O algoritmo de seleção do jQuery funciona da esquerda para a direita"></a>3. O algoritmo de seleção do jQuery funciona da esquerda para a direita</h2><p>Isso significa que o lado direto da query de busca precisa ser o mais específico possivel. Neste caso, queries muito longas acabam não fazendo muito sentido e podem ser evitadas. Exemplo:</p><blockquote><p>Ruim</p></blockquote><pre><code>$(&apos;div.page div.block .element&apos;)</code></pre><blockquote><p>Bom</p></blockquote><pre><code>$(&apos;.page div.element&apos;)</code></pre><blockquote><p>Sempre que possível utilize <em>tag + class</em></p></blockquote><h2 id="4-Quebre-sua-query-em-blocos-sempre-que-possivel"><a href="#4-Quebre-sua-query-em-blocos-sempre-que-possivel" class="headerlink" title="4. Quebre sua query em blocos sempre que possível"></a>4. Quebre sua query em blocos sempre que possível</h2><p>Seguindo o conceito do item (3) considere os seguintes códigos:</p><blockquote><p>Ruim</p></blockquote><pre><code>$(&apos;#container .element&apos;)</code></pre><blockquote><p>Bom</p></blockquote><pre><code>$(&apos;#container&apos;).find(&apos;.element&apos;)</code></pre><p>Lembre-se que a busca é sempre feita da direita para a esquerda e por isso, no primeiro exemplo o jQuery irá primeiro buscar por todos os elementos com a classe <code>element</code> e depois filtrar todos os elementos que contenham o id <code>container</code>.</p><p>Uma outra sintaxe similar ao método <code>find(...)</code> é:</p><pre><code>$(&apos;.element&apos;, &apos;#container&apos;)</code></pre><h2 id="5-Faca-sempre-um-cache-dos-seus-seletores"><a href="#5-Faca-sempre-um-cache-dos-seus-seletores" class="headerlink" title="5. Faça sempre um cache dos seus seletores"></a>5. Faça sempre um cache dos seus seletores</h2><p>Este item é muito simular ao anterior. Os exemplos de código abaixo falam por sí só:</p><blockquote><p>Ruim</p></blockquote><pre><code>var block = $(&apos;.block&apos;);var elements = $(&apos;.block&apos;).find(&apos;.element&apos;);var title = $(&apos;.block&apos;).data(&apos;title&apos;);</code></pre><blockquote><p>Bom</p></blockquote><pre><code>var block = $(&apos;.block&apos;);var elements = block.find(&apos;.element&apos;);var title = block.data(&apos;title&apos;);</code></pre><h2 id="6-Evite-a-manipulacao-pesada-do-DOM"><a href="#6-Evite-a-manipulacao-pesada-do-DOM" class="headerlink" title="6. Evite a manipulação pesada do DOM"></a>6. Evite a manipulação pesada do DOM</h2><p>Você pode se surpreender com a quantidade de elementos que é possível manipular utilizando JavaScript. No entanto, se estes elementos estiverem ligados ao DOM essa surpreza será ruim. Manipular elementos no DOM é uma operação muito lenta e quanto mais elementos você precise manipular, pior será a performance.</p><p>A melhor forma de fazer isso utilizando jQuery é primiro “desacoplar” esses elementos no DOM, manipular e depois retorná-los ao DOM. Exemplo:</p><pre><code>var elem = $(&apos;.element&apos;);var parent = elem.parent();elem.detach();... operações muito pesadas, ordenação de tabelas por exemplo ...parent.append(elem);</code></pre><h2 id="7-Evite-“appends”-desnecessarios"><a href="#7-Evite-“appends”-desnecessarios" class="headerlink" title="7. Evite “appends” desnecessários"></a>7. Evite “appends” desnecessários</h2><p>Ao invés de ficar utilizando o método <code>append(...)</code> pra cada elemento que estiver adicionando, procure sempre montar uma string HTML e utiliar o <code>append(...)</code> de uma só vez.</p><h2 id="8-Prefira-utilizar-data-no-lugar-de-attr"><a href="#8-Prefira-utilizar-data-no-lugar-de-attr" class="headerlink" title="8. Prefira utilizar data() no lugar de attr()"></a>8. Prefira utilizar data() no lugar de attr()</h2><p>O método <code>attr(...)</code> escreve os atributos direto no DOM, e como falamos no item (6), qualquer manipulação direta do DOM deve ser evitada sempre que possível por questões de performance.</p><blockquote><p>NOTA: a utilização de <code>data(...)</code> embora preferível pelas questões citadas, deve ser verificada com cautela. Se voce estiver utilizando uma biblioteca de terceiros que esteja manipulando os atributos direto no DOM você poderá ter problemas.</p></blockquote><h2 id="9-Verifique-se-o-elemento-realmente-existe-antes-de-usa-lo"><a href="#9-Verifique-se-o-elemento-realmente-existe-antes-de-usa-lo" class="headerlink" title="9. Verifique se o elemento realmente existe antes de usá-lo"></a>9. Verifique se o elemento realmente existe antes de usá-lo</h2><blockquote><p>Ruim</p></blockquote><pre><code>$(&apos;.element&apos;).slideDown();// esse ponto executa uma chamada pesada que efetua vários// cálculos mesmo se o elemento não existir</code></pre><blockquote><p>Bom</p></blockquote><pre><code>var element = $(&apos;.element&apos;);if (element.length) {    element.slideDown();}</code></pre><p>Verificar se o elemento existe antes de efetuar algumas operações evita que alguns algoritmos sejam executados desnecessáriamente.</p><h2 id="10-Evite-a-utilizacao-de-loops"><a href="#10-Evite-a-utilizacao-de-loops" class="headerlink" title="10. Evite a utilização de loops"></a>10. Evite a utilização de loops</h2><blockquote><p>Ruim</p></blockquote><pre><code>$(&apos;.element&apos;).each(function() {    $(this).something().somethingElse();});</code></pre><blockquote><p>Bom</p></blockquote><pre><code>$(&apos;.element&apos;).something().somethingElse();</code></pre><p>A API do jQuery nos permite executar muitas operações em grupo baseado no resultado da query. Utilize as operações em grupo sempre que possível.</p><h2 id="Conclusao"><a href="#Conclusao" class="headerlink" title="Conclusão"></a>Conclusão</h2><p>jQuery é sem dúvida uma das bibliotecas javascript mais utilizadas e dificilmente perderá esse ranking. Por isso, vale a pena entender melhor como esta biblioteca funciona para utiliza-la da maneira mais correta possível.</p><p>Até a próxima!</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Os anos se passaram e o jQuery continua relevante em pleno 2016. A facilidade de manipulação e a infinidade de artigos na internet ajuda a reforçar a utilização do jQuery e a manter essa biblioteca viva. De fato, poucos anos atrás, escrever codigo compatível com diferentes versões de navegadores seria um trabalho muito árduo se não fosse pelo nosso amigo jQuery.&lt;/p&gt;
&lt;p&gt;O grande problema com o jQuery é que muitos desenvolvedores ignoram as boas práticas e escrevem codigo muito pobres em performance (isso sem falar sobre design de código).&lt;/p&gt;
&lt;h2 id=&quot;Por-que-performance-e-importante&quot;&gt;&lt;a href=&quot;#Por-que-performance-e-importante&quot; class=&quot;headerlink&quot; title=&quot;Por que performance é importante?&quot;&gt;&lt;/a&gt;Por que performance é importante?&lt;/h2&gt;&lt;p&gt;Vou expor duas boas razões:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Uma boa performance pode trazer uma boa experiência de uso. Nem sempre seus visitanes vão lhe dizer que seu site está lento, eles simplesmente não vão voltar a acessar o site.&lt;/li&gt;
&lt;li&gt;O Google leva a performance em consideração para a classificação do seu site no PageRank.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Então, vamos aos pontos…&lt;/p&gt;
    
    </summary>
    
      <category term="JavaScript" scheme="http://diullei.com/categories/JavaScript/"/>
    
      <category term="jQuery" scheme="http://diullei.com/categories/JavaScript/jQuery/"/>
    
    
      <category term="JavaScript" scheme="http://diullei.com/tags/JavaScript/"/>
    
      <category term="jQuery" scheme="http://diullei.com/tags/jQuery/"/>
    
  </entry>
  
  <entry>
    <title>Arrays tipados - ES6</title>
    <link href="http://diullei.com/2016/10/28/Arrays-tipados-ES6/"/>
    <id>http://diullei.com/2016/10/28/Arrays-tipados-ES6/</id>
    <published>2016-10-27T22:00:00.000Z</published>
    <updated>2019-01-07T23:15:42.331Z</updated>
    
    <content type="html"><![CDATA[<p>Os arrays tipados são parte da especificação do ECMAScript 2015 (também conhecido como ES6). Eles foram projetados para facilitar o trabalho com estruturas de dados binárias. Inicialmente os arrays tipados foram introduzidos pelas APIs WebGL com o objetivo de diminuir a dissonância entre as estruturas de dados padrões do <code>JavaScript</code> e as estruturas de dados do <code>C</code>, linguagem base da API <code>WebGL</code>, e com isso permitir ao JavaScript acessar diretamente a estrutura já alocada em memória.</p><p>Você pode acessar este <a href="http://caniuse.com/#feat=typedarrays" target="_blank" rel="noopener">link</a> para saber quais browsers já suportam esse recurso: <a href="http://caniuse.com/#feat=typedarrays" target="_blank" rel="noopener">http://caniuse.com/#feat=typedarrays</a></p><h2 id="Criando-Arrays-tipados"><a href="#Criando-Arrays-tipados" class="headerlink" title="Criando Arrays tipados"></a>Criando Arrays tipados</h2><p>Aqui não existe nenhum segredo, criamos um array tipado da mesma forma que criarpiamos qualquer instância de objeto. em JavaScript:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = <span class="keyword">new</span> <span class="built_in">Uint16Array</span>(<span class="number">10</span>);</span><br><span class="line">arr[<span class="number">0</span>] = <span class="number">0xFFFF</span>;</span><br><span class="line"><span class="built_in">console</span>.log(arr[<span class="number">0</span>]);</span><br></pre></td></tr></table></figure><a id="more"></a><p>O argumento passado no construtor define o número de elementos que estamos alocando neste array (No exemplo acima estamos alocando 10 elementos do tipo numérico <code>uint16</code>, o que de acordo com a especificação deste tipo de array irá alocar 20 bytes de memória).</p><p>Veja abaixo uma lista com os tipos de arrays tipados disponíveis:</p><table><thead><tr><th style="text-align:left">Tipo</th><th style="text-align:center">Tamanho (byte)</th><th style="text-align:left">Tipo correspondente em C</th></tr></thead><tbody><tr><td style="text-align:left"><code>Int8Array</code></td><td style="text-align:center">1</td><td style="text-align:left">int8_t</td></tr><tr><td style="text-align:left"><code>Uint8Array</code></td><td style="text-align:center">1</td><td style="text-align:left">uint8_t</td></tr><tr><td style="text-align:left"><code>Uint8ClampedArray</code></td><td style="text-align:center">1</td><td style="text-align:left">uint8_t</td></tr><tr><td style="text-align:left"><code>Int16Array</code></td><td style="text-align:center">2</td><td style="text-align:left">int16_t</td></tr><tr><td style="text-align:left"><code>Uint16Array</code></td><td style="text-align:center">2</td><td style="text-align:left">uint16_t</td></tr><tr><td style="text-align:left"><code>Int32Array</code></td><td style="text-align:center">4</td><td style="text-align:left">int32_t</td></tr><tr><td style="text-align:left"><code>Uint32Array</code></td><td style="text-align:center">4</td><td style="text-align:left">uint32_t</td></tr><tr><td style="text-align:left"><code>Float32Array</code></td><td style="text-align:center">4</td><td style="text-align:left">float</td></tr><tr><td style="text-align:left"><code>Float64Array</code></td><td style="text-align:center">8</td><td style="text-align:left">double</td></tr></tbody></table><h2 id="ArrayBuffer-e-DataView"><a href="#ArrayBuffer-e-DataView" class="headerlink" title="ArrayBuffer e DataView"></a>ArrayBuffer e DataView</h2><p><code>ArrayBuffer</code> e <code>DataView</code> são parte da implementação de arrays tipados. Um <code>ArrayBuffer</code> básicamente armazena os dados de um array tipado. Por exemplo:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> fileArrayBuffer = reader.readAsArrayBuffer(file);</span><br></pre></td></tr></table></figure><p>Neste código <code>ArrayBuffer</code> ira armazenar todos os bytes do arquivo. Como esse arquivo pode estar em encodes diferentes, precisaremos fazer alguma manipulação para ler seu conteúdo. Por exemplo, se este arquivo for do tipo <code>UTF-8</code> poderemos associar este <code>ArrayBuffer</code> ao tipo <code>Uint16Array</code> para ler corretamente seu conteúdo.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = <span class="keyword">new</span> <span class="built_in">Uint16Array</span>(fileArrayBuffer);</span><br><span class="line"><span class="built_in">String</span>.fromCharCode(arr[<span class="number">0</span>]); <span class="comment">// A</span></span><br></pre></td></tr></table></figure><p>Já o <code>DataView</code> é um tipo que nos permite acessar estruturas binrias em memória. Exemplo, se tivermos uma estrutura em <code>C</code> declarada da seguinte forma:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">data</span> &#123;</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> id;</span><br><span class="line">    <span class="keyword">char</span>[<span class="number">10</span>] username;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Iremos ler esta estrutura em JavaScript com o código:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> buf = <span class="keyword">new</span> <span class="built_in">ArrayBuffer</span>(<span class="number">11</span>);</span><br><span class="line"><span class="keyword">var</span> id = <span class="keyword">new</span> <span class="built_in">Uint8Array</span>(buf, <span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line"><span class="keyword">var</span> username = <span class="keyword">new</span> <span class="built_in">Uint8Array</span>(buf, <span class="number">1</span>, <span class="number">10</span>);</span><br></pre></td></tr></table></figure><p>Note que se trata de uma leitura sequencial da memória onde o primeiro byte contém o valor de <code>id</code> e os outros 10 bytes seguintes o valor de <code>username</code>. Aqui estamos utilizando <code>Uint8Array</code> como <code>DataView</code>.</p><h2 id="Onde-esse-recurso-ja-esta-sendo-utilizado"><a href="#Onde-esse-recurso-ja-esta-sendo-utilizado" class="headerlink" title="Onde esse recurso ja está sendo utilizado?"></a>Onde esse recurso ja está sendo utilizado?</h2><ul><li><strong>WebGL</strong> - Utiliza typed arrays em buffer, pixels e mapas de testuras</li><li><strong>Canvas</strong> - Canvas utiliza um arrau tipado para armazenar uma imagem.</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> uint8ClampedArray = ctx.getImageData(...).data;</span><br></pre></td></tr></table></figure><ul><li><strong>WebSockets</strong> - Uma vez habilitado permite a transferência de dados utilizando um <code>ArrayBuffer</code>.</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">webSocket.binaryType = <span class="string">'arraybuffer'</span>;</span><br></pre></td></tr></table></figure><ul><li><strong>Outras APIs</strong> - <em>File API</em>, <em>XMLHttpRequest,</em> <em>Fetch API</em>, <code>window.postMessage()</code> entre outros.</li></ul><h2 id="Conclusao"><a href="#Conclusao" class="headerlink" title="Conclusão"></a>Conclusão</h2><p>Iremos utilizar os Arrays typados em trechos de código muito específicos onde a performance com a manipulação de estruturas de dados mais complexas for importante, como por exemplo a manipulação de imagens e de som.</p><p>É isso, até a próxima.</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Os arrays tipados são parte da especificação do ECMAScript 2015 (também conhecido como ES6). Eles foram projetados para facilitar o trabalho com estruturas de dados binárias. Inicialmente os arrays tipados foram introduzidos pelas APIs WebGL com o objetivo de diminuir a dissonância entre as estruturas de dados padrões do &lt;code&gt;JavaScript&lt;/code&gt; e as estruturas de dados do &lt;code&gt;C&lt;/code&gt;, linguagem base da API &lt;code&gt;WebGL&lt;/code&gt;, e com isso permitir ao JavaScript acessar diretamente a estrutura já alocada em memória.&lt;/p&gt;
&lt;p&gt;Você pode acessar este &lt;a href=&quot;http://caniuse.com/#feat=typedarrays&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;link&lt;/a&gt; para saber quais browsers já suportam esse recurso: &lt;a href=&quot;http://caniuse.com/#feat=typedarrays&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;http://caniuse.com/#feat=typedarrays&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;Criando-Arrays-tipados&quot;&gt;&lt;a href=&quot;#Criando-Arrays-tipados&quot; class=&quot;headerlink&quot; title=&quot;Criando Arrays tipados&quot;&gt;&lt;/a&gt;Criando Arrays tipados&lt;/h2&gt;&lt;p&gt;Aqui não existe nenhum segredo, criamos um array tipado da mesma forma que criarpiamos qualquer instância de objeto. em JavaScript:&lt;/p&gt;
&lt;figure class=&quot;highlight javascript&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; arr = &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;built_in&quot;&gt;Uint16Array&lt;/span&gt;(&lt;span class=&quot;number&quot;&gt;10&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;arr[&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;] = &lt;span class=&quot;number&quot;&gt;0xFFFF&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;console&lt;/span&gt;.log(arr[&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;]);&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="JavaScript" scheme="http://diullei.com/categories/JavaScript/"/>
    
      <category term="ES6" scheme="http://diullei.com/categories/JavaScript/ES6/"/>
    
    
      <category term="JavaScript" scheme="http://diullei.com/tags/JavaScript/"/>
    
      <category term="ES6" scheme="http://diullei.com/tags/ES6/"/>
    
  </entry>
  
  <entry>
    <title>Definindo o tipo de &quot;this&quot; em funções</title>
    <link href="http://diullei.com/2016/10/27/Type-of-this-for-functions/"/>
    <id>http://diullei.com/2016/10/27/Type-of-this-for-functions/</id>
    <published>2016-10-26T22:00:00.000Z</published>
    <updated>2019-01-07T23:15:42.331Z</updated>
    
    <content type="html"><![CDATA[<p>O TypeScript 2.0 nos permite definir o tipo da referência <code>this</code> dentro de uma função. Como sempre, para entender melhor, vamos aos exemplos:</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> Test &#123;</span><br><span class="line">    <span class="keyword">public</span> doSomething() &#123;</span><br><span class="line">        <span class="keyword">let</span> self = <span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Na função <code>doSomething()</code> a variavel <code>self</code> assume o tipo <code>Test</code>. Até aqui nada novo. Agora vamos a outro exemplo:</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">doSomething</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> self = <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><a id="more"></a><p>Na função <code>doSomething()</code> acima a variável <code>self</code> assume o tipo <code>any</code>. Isso por que se trata de uma função isolada, fora de uma classe. O que acontece é que agora com a nova versão do TypeScript podemos definir o tipo de <code>this</code> para funções isoladas. Vamos tomar como base a função <code>doSomething()</code>. Digamos que queiramos impedir que um desenvolvedor, por engano, tente chamar qualquer método ou atributo de <code>this</code> dentro desta função. Para isso vamos reescrever essa função da seguinte forma:</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">doSomething</span>(<span class="params"><span class="keyword">this</span>: <span class="built_in">void</span></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> self = <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Agora o tipo de <code>self</code> é <code>void</code>. Como <code>void</code> não poss membros, caso alguem tente chamar qualquer um de seus membros por engano um erro será exibido em tempo de compilação. Utilizamos uma nova notação onde criamos um argumento chamado <code>this</code> e definimos seu tipo. Esse argumento precisa ser sempre o primeiro argumento dentro da função e ele não será repassado para o código final servindo apenas para informar ao compilador o tipo que queremos definir para <code>this</code>.</p><p>Agora vamos a um exemplo mais prático. Veja a seguinte interface:</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> UIElement &#123;</span><br><span class="line">    addClickListener(onclick: <span class="function">(<span class="params"><span class="keyword">this</span>: <span class="built_in">void</span>, e: Event</span>) =&gt;</span> <span class="built_in">void</span>): <span class="built_in">void</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Note que a função <code>addClickListener(...)</code> espera uma outra função como parâmetro que não utilize <code>this</code> no seu bloco de código. Se temtarmos passar uma função que viole essa definição teremos um erro:</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> UIElement &#123;</span><br><span class="line">    addClickListener(onclick: <span class="function">(<span class="params"><span class="keyword">this</span>: <span class="built_in">void</span>, e: Event</span>) =&gt;</span> <span class="built_in">void</span>): <span class="built_in">void</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> uiElement: UIElement = &lt;<span class="built_in">any</span>&gt;&#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> Handler &#123;</span><br><span class="line">    info: <span class="built_in">string</span>;</span><br><span class="line">    onClickBad(<span class="keyword">this</span>: Handler, e: Event) &#123;</span><br><span class="line">        <span class="keyword">this</span>.info = <span class="string">"message"</span>;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> h = <span class="keyword">new</span> Handler();</span><br><span class="line">uiElement.addClickListener(h.onClickBad); <span class="comment">// erro!</span></span><br></pre></td></tr></table></figure><p>Veja que dentro da função <code>onClickBad()</code> estamos usando <code>this</code> normalmente. Mas se tentarmos passar a função <code>onClickBad</code> como argumento em <code>addClickListener(...)</code>…</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">uiElement.addClickListener(h.onClickBad); <span class="comment">// erro!</span></span><br></pre></td></tr></table></figure><p>…teremos um erro de compilação.</p><blockquote><p>NOTA: Para utilizar este recurso precisamos habilitar a chave <code>--noImplicitThis</code> bo arquivo <code>tsconfig.json</code> ou passando diretamente via linha de comando.</p></blockquote><p>É isso. Até a próxima.</p><blockquote><p>Reference: TS v2.0 <a href="https://github.com/Microsoft/TypeScript/issues/3694" target="_blank" rel="noopener">issues/3694</a> e <a href="https://github.com/Microsoft/TypeScript/pull/4910" target="_blank" rel="noopener">pull/4910</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;O TypeScript 2.0 nos permite definir o tipo da referência &lt;code&gt;this&lt;/code&gt; dentro de uma função. Como sempre, para entender melhor, vamos aos exemplos:&lt;/p&gt;
&lt;figure class=&quot;highlight typescript&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; Test &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; doSomething() &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;let&lt;/span&gt; self = &lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;Na função &lt;code&gt;doSomething()&lt;/code&gt; a variavel &lt;code&gt;self&lt;/code&gt; assume o tipo &lt;code&gt;Test&lt;/code&gt;. Até aqui nada novo. Agora vamos a outro exemplo:&lt;/p&gt;
&lt;figure class=&quot;highlight typescript&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;doSomething&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;&lt;/span&gt;) &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;let&lt;/span&gt; self = &lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="TypeScript" scheme="http://diullei.com/categories/TypeScript/"/>
    
      <category term="TypeScript v2.0" scheme="http://diullei.com/categories/TypeScript/TypeScript-v2-0/"/>
    
    
      <category term="TypeScript" scheme="http://diullei.com/tags/TypeScript/"/>
    
  </entry>
  
  <entry>
    <title>TypeScript e o tipo &quot;never&quot;</title>
    <link href="http://diullei.com/2016/10/26/TypeScript-and-the-Never-type/"/>
    <id>http://diullei.com/2016/10/26/TypeScript-and-the-Never-type/</id>
    <published>2016-10-25T22:00:00.000Z</published>
    <updated>2019-01-07T23:15:42.331Z</updated>
    
    <content type="html"><![CDATA[<p>Continuando a série de artigos sobre as novidades da versão 2.0 do TypeScript hoje eu vou falar um pouco sobre o tipo <code>never</code>.</p><p>Como vimos no post sobre <a href="/posts/Tagged-union-types">união discriminada de tipos</a> e em outro post sobre <a href="/posts/TypeScript-Type-Guards">type guards</a>, o compilador do TypeScript possui um recurso que analiza todas as possíveis rotas de fluxo no código que está sendo compilado com o objetivo de definir da forma mais precisa possível o tipo das variáveis que estão sendo utilizadas (Veja o ultimo post <a href="/posts/Tagged-union-types">“união discriminada de tipos”</a> para entender um pouco mais).</p><p>Em um aplicativo, em alguns casos, teremos fluxos no código que nuca serão executados. Por causa disso, para prover uma analize de código mais completa o time do TypeScript inseriu um novo tipo chamado <code>never</code>. Entenda o tipo <code>never</code> com a representação de valores que nunca serão retornados.</p><p>Encontraremos o tipo <code>never</code> no código de 2 maneiras diferentes. Ele pode ocorrer naturalmente. Por exemplo:</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> result = <span class="function">(<span class="params">(<span class="params"></span>) =&gt; &#123;</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">while</span> (<span class="params"><span class="literal">true</span></span>) &#123;</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="comment">//...</span></span></span></span><br><span class="line"><span class="function"><span class="params">    &#125;</span></span></span><br><span class="line"><span class="function"><span class="params">&#125;</span>)<span class="params">()</span>;</span></span><br><span class="line"><span class="function">// <span class="params">let</span> <span class="params">result</span>: <span class="params">never</span></span></span><br></pre></td></tr></table></figure><a id="more"></a><p>Se observarmos o código da função anônima acima veremos um “loop infinito”, o código fica eternamente executando dentro do bloco <code>while</code> e nunca retorna um valor, ou seja, nunca finaliza. Como o compilador do TypeScript analiza todo código que está sendo escrito, ele entende naturalmente que se trata de um bloco de código que nunca será executado e por isso, no nosso caso, ele define o valor de retorno da função como <code>never</code>.</p><p>Além de fluxos com “loop infinito” o compilador também irá inferir o tipo <code>never</code> para funções que lançam exceção em seu fluxo principal. Exemplo:</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">error</span>(<span class="params">message: <span class="built_in">string</span></span>): <span class="title">never</span> </span>&#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(message);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Inferred return type is never</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fail</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> error(<span class="string">"Something failed"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> result = fail();</span><br><span class="line"><span class="comment">// let result: never</span></span><br></pre></td></tr></table></figure><p>A outra forma de encontrar o tipo <code>never</code> é quando declaramos diretamente este tipo. Exemplo:</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">alwaysNever</span>(<span class="params"></span>): <span class="title">never</span> </span>&#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">"!"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Confundindo-o-tipo-“never”-com-o-tipo-“void”"><a href="#Confundindo-o-tipo-“never”-com-o-tipo-“void”" class="headerlink" title="Confundindo o tipo “never” com o tipo “void”"></a>Confundindo o tipo “never” com o tipo “void”</h3><p>É muito comum a primeira vista alguem confundir o tipo <code>never</code> com o tipo <code>void</code>, mas se olharmos com mais atenção veremos que são tipos completamente diferentes. Para explicar melhor essa diferença vamos a um caso de uso:</p><p>Antes de termos o tipo <code>never</code> o código acima (função <code>function alwaysNever() { ... }</code>) seria reconhecido como sendo do tipo <code>void</code>. Algo similar ao código abaixo:</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">alwaysThrows</span>(<span class="params"></span>): <span class="title">void</span> </span>&#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">"!"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Como <code>void</code> não é um subtipo, a auusencia do tipo <code>never</code> ocasionava em alguns momentos alguns efeitos colaterais, veja o exemplo abaixo:</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">alwaysThrows</span>(<span class="params"></span>): <span class="title">void</span> </span>&#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">"!"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params">a: <span class="built_in">boolean</span></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a ? <span class="number">123</span> : alwaysThrows();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> result = test(<span class="literal">false</span>);</span><br></pre></td></tr></table></figure><p>Se verificarmos no código acima, com a ausencia do tipo <code>never</code> a variável <code>result</code> assume o tipo <code>number | void</code>. Isso é um erro por que se verificarmos o retorno da função <code>test(...)</code> tendo o argument <code>a</code> como <code>false</code> teremos na realidade uma exceção e nunca um valor do tipo <code>void</code>. Com isso em mente o tipo da variável <code>result</code> deve ser entendido como <code>number</code> já que temos como unica possibilidadde de retorno é o valor <code>123</code>. O tipo <code>never</code> nos ajuda a arrumar este efeito colateral pois <code>never</code> é um subtipo de todos os outros tipos conhecidos.</p><p>Reescrevendo o código acima temos:</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">alwaysThrows</span>(<span class="params"></span>): <span class="title">never</span> </span>&#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">"!"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params">a: <span class="built_in">boolean</span></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a ? <span class="number">123</span> : alwaysThrows();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> result = test(<span class="literal">false</span>);</span><br></pre></td></tr></table></figure><p>Agora o compilador irá entender corretamente o código e definir o tipo da variavel <code>result</code> como <code>number</code>.</p><p>É isso, até a próxima!</p><blockquote><p>Reference: TS v2.0 <a href="https://github.com/Microsoft/TypeScript/pull/8652" target="_blank" rel="noopener">pull/8652</a> e <a href="https://github.com/Microsoft/TypeScript/issues/3076" target="_blank" rel="noopener">issues/3076</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Continuando a série de artigos sobre as novidades da versão 2.0 do TypeScript hoje eu vou falar um pouco sobre o tipo &lt;code&gt;never&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;Como vimos no post sobre &lt;a href=&quot;/posts/Tagged-union-types&quot;&gt;união discriminada de tipos&lt;/a&gt; e em outro post sobre &lt;a href=&quot;/posts/TypeScript-Type-Guards&quot;&gt;type guards&lt;/a&gt;, o compilador do TypeScript possui um recurso que analiza todas as possíveis rotas de fluxo no código que está sendo compilado com o objetivo de definir da forma mais precisa possível o tipo das variáveis que estão sendo utilizadas (Veja o ultimo post &lt;a href=&quot;/posts/Tagged-union-types&quot;&gt;“união discriminada de tipos”&lt;/a&gt; para entender um pouco mais).&lt;/p&gt;
&lt;p&gt;Em um aplicativo, em alguns casos, teremos fluxos no código que nuca serão executados. Por causa disso, para prover uma analize de código mais completa o time do TypeScript inseriu um novo tipo chamado &lt;code&gt;never&lt;/code&gt;. Entenda o tipo &lt;code&gt;never&lt;/code&gt; com a representação de valores que nunca serão retornados.&lt;/p&gt;
&lt;p&gt;Encontraremos o tipo &lt;code&gt;never&lt;/code&gt; no código de 2 maneiras diferentes. Ele pode ocorrer naturalmente. Por exemplo:&lt;/p&gt;
&lt;figure class=&quot;highlight typescript&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;let&lt;/span&gt; result = &lt;span class=&quot;function&quot;&gt;(&lt;span class=&quot;params&quot;&gt;(&lt;span class=&quot;params&quot;&gt;&lt;/span&gt;) =&amp;gt; &amp;#123;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;params&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;while&lt;/span&gt; (&lt;span class=&quot;params&quot;&gt;&lt;span class=&quot;literal&quot;&gt;true&lt;/span&gt;&lt;/span&gt;) &amp;#123;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;params&quot;&gt;        &lt;span class=&quot;comment&quot;&gt;//...&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;params&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;params&quot;&gt;&amp;#125;&lt;/span&gt;)&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt;;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;// &lt;span class=&quot;params&quot;&gt;let&lt;/span&gt; &lt;span class=&quot;params&quot;&gt;result&lt;/span&gt;: &lt;span class=&quot;params&quot;&gt;never&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="TypeScript" scheme="http://diullei.com/categories/TypeScript/"/>
    
      <category term="TypeScript v2.0" scheme="http://diullei.com/categories/TypeScript/TypeScript-v2-0/"/>
    
    
      <category term="TypeScript" scheme="http://diullei.com/tags/TypeScript/"/>
    
  </entry>
  
  <entry>
    <title>União discriminada de tipos (Tagged union types)</title>
    <link href="http://diullei.com/2016/10/25/Tagged-union-types/"/>
    <id>http://diullei.com/2016/10/25/Tagged-union-types/</id>
    <published>2016-10-24T22:00:00.000Z</published>
    <updated>2019-01-07T23:15:42.331Z</updated>
    
    <content type="html"><![CDATA[<p>Hoje vou falar sobre uma feature muito legal que desenbarcou junto com a versão 2.0 to TypeScript, a união discriminada de tipos. Trata-se de uma extensão do recurso <a href="/posts/TypeScript-Type-Guards">type guards</a> que baseia a verificação do tipo dentro de um determinado fluxo do código, tomando como base valor de uma propriedade. A definição pode parecer um pouco confusa, por isso vamos a um exemplo:</p><a id="more"></a><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> Square &#123;</span><br><span class="line">    kind: <span class="string">"square"</span>;</span><br><span class="line">    size: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> Rectangle &#123;</span><br><span class="line">    kind: <span class="string">"rectangle"</span>;</span><br><span class="line">    width: <span class="built_in">number</span>;</span><br><span class="line">    height: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> Circle &#123;</span><br><span class="line">    kind: <span class="string">"circle"</span>;</span><br><span class="line">    radius: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Shape = Square | Rectangle | Circle;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">area</span>(<span class="params">s: Shape</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// Repare que no bloco switch abaixo, o tipo da variável "s" é reconhecido pelo</span></span><br><span class="line">    <span class="comment">// compilador de forma diferente em cada bloco condicional. O compilador define</span></span><br><span class="line">    <span class="comment">// o tipo correto baseado no valor da propriedade "kind" definida nas interfaces</span></span><br><span class="line">    <span class="comment">// acima como um valor constante. Por esse motivo podemos utilizar as propriedades</span></span><br><span class="line">    <span class="comment">// específicas de cada interface sem precisar fazer uma conversão (cast).</span></span><br><span class="line">    <span class="keyword">switch</span> (s.kind) &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">"square"</span>: <span class="keyword">return</span> s.size * s.size;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">"rectangle"</span>: <span class="keyword">return</span> s.width * s.height;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">"circle"</span>: <span class="keyword">return</span> <span class="built_in">Math</span>.PI * s.radius * s.radius;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Repare como nas funções abaixo o compilador entende a lógica aplicada nos if's e</span></span><br><span class="line"><span class="comment">// interpreta o tipo de "s" de acordo com a propriedade "kind".</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">test1</span>(<span class="params">s: Shape</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (s.kind === <span class="string">"square"</span>) &#123;</span><br><span class="line">        s;  <span class="comment">// Aqui "s" é do tipo: "Square"</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        s;  <span class="comment">// Aqui "s" é do tipo: "Rectangle | Circle"</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">test2</span>(<span class="params">s: Shape</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (s.kind === <span class="string">"square"</span> || s.kind === <span class="string">"rectangle"</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    s;  <span class="comment">// Aqui "s" é do tipo "Circle"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Por enquanto esse recurso opera apenas sobre propriedades tipo <code>string</code>. Existe a intenção de, no futuro, adicionar suporte a outros tipo como <code>boolean</code> e <code>number</code>.</p><p>Esper oque este post tenha sido útil.</p><p>Até a próxima!</p><blockquote><p>Reference: TS v2.0 <a href="https://github.com/Microsoft/TypeScript/pull/9163" target="_blank" rel="noopener">pull/9163</a>, <a href="https://github.com/Microsoft/TypeScript/issues/186" target="_blank" rel="noopener">issues/186</a> e <a href="https://github.com/Microsoft/TypeScript/issues/1003" target="_blank" rel="noopener">issues/1003</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Hoje vou falar sobre uma feature muito legal que desenbarcou junto com a versão 2.0 to TypeScript, a união discriminada de tipos. Trata-se de uma extensão do recurso &lt;a href=&quot;/posts/TypeScript-Type-Guards&quot;&gt;type guards&lt;/a&gt; que baseia a verificação do tipo dentro de um determinado fluxo do código, tomando como base valor de uma propriedade. A definição pode parecer um pouco confusa, por isso vamos a um exemplo:&lt;/p&gt;
    
    </summary>
    
      <category term="TypeScript" scheme="http://diullei.com/categories/TypeScript/"/>
    
      <category term="TypeScript v2.0" scheme="http://diullei.com/categories/TypeScript/TypeScript-v2-0/"/>
    
    
      <category term="TypeScript" scheme="http://diullei.com/tags/TypeScript/"/>
    
  </entry>
  
  <entry>
    <title>TypeScript 2.0</title>
    <link href="http://diullei.com/2016/10/24/TypeScript-2/"/>
    <id>http://diullei.com/2016/10/24/TypeScript-2/</id>
    <published>2016-10-23T22:00:00.000Z</published>
    <updated>2019-01-07T23:15:42.331Z</updated>
    
    <content type="html"><![CDATA[<p>Finalmente consegui voltar a ativa depois de algum tempo sem escrever. Hoje vou falar sobre a ultima versão do TypeScript, a versão 2.0. Essa versão é o resultado de muito trabalho e esforço do time do TypeScript e da comunidade.</p><p>Para começar a utilizar esta nova versão você pode baixar via npm utilizando o seguinte comando:</p><blockquote><p>npm install -g typescript@2.0</p></blockquote><p>Pronto! Agora você já está pronto para começar a explorar as novas features!</p><a id="more"></a><h2 id="Um-pouco-de-historia-Acontecimentos-principais"><a href="#Um-pouco-de-historia-Acontecimentos-principais" class="headerlink" title="Um pouco de história (Acontecimentos principais)"></a>Um pouco de história (Acontecimentos principais)</h2><ul><li><p><em>TypeScript 0.8</em> - Em Outubro de 2012 os desenvolvedores foram surpreendidos com o que muitos chamavam de “O CofeeScript da Microsoft”. O TypeScript veio ao mundo e muitos começaram a entender as inúmeras possibilidades de se ter uma linguagem mundialmente popular como o <code>JavaScript</code> mesclada a um forte sistema de tipos (que na época nem era tão forte assim rs).</p></li><li><p><em>DefinitelyTyped</em> - Alguns meses depois do lançamento do TypeScript a comunidade começou a se movimentar. Nesta época eu iniciei a construção do <a href="https://github.com/DefinitelyTyped/tsd" target="_blank" rel="noopener">TSD</a> com a intenção de aprender mais sobre TypeScript e ao mesmo tempo criar alguma ferramenta que fosse útil não apenas pra mim, mas para outros desenvolvedores. Conversando em fóruns com outros desenvolvedores entusiastas (que eram poucos na época) eu puder conhecer alguns pessoas que hoje são figuras bastante conhecidas entre os desenvolvedores TypeScript e pudemos juntos montar o time <a href="https://github.com/DefinitelyTyped" target="_blank" rel="noopener">DefinitelyTyped</a>.</p></li><li><p><em>TypeScript 1.0</em> - Há alguns anos atrás a versão 1.0 do TypeScript foi disponibilizada e com ela os desenvolvedores puderam entender o potencial do trabalho com JavaScript combinado com um forte sistema de tipagem estática. Alertas de erro em tempo de compilação, editores com recursos de navegação e refatoração, entre outras ferramentas trouxeram para os desenvolvedores um enorme ganho de produtividade.</p></li><li><p><em>TypeScript 1.1</em> - A versão 1.1 trouxe um compilador totalmente reescrito que passou a executar 4x mais rápido que o anterior. Com este novo compilador ganhamos, além da velocidade de compilação, uma grande flexibilidade ma interação com o código para adição de novas features. Uma outra grande mudança foi a migração do código do TypeScript do <a href="https://typescript.codeplex.com/" target="_blank" rel="noopener">Codeplex</a> para o <a href="https://github.com/Microsoft/TypeScript" target="_blank" rel="noopener">Github</a>. Essa sem dúvidade potêncializou muito a comunicação com a comunidade permitindo uma maior participação e contrinbuição, seja ajudando a especificar novas fetures, submetendo bugs ou programando diretamente no código do compilador.</p></li><li><p><em>TypeScript 1.4 e 1.5</em> - Essa versão trouxe um grande suporte a features do <code>ES2015/ES6</code>. Juntamente com isso passamos a ter suporte a modules e decorators, o que permitiu ao time do <code>Angular2</code> adotar o TypeSCript como linguagem oficial. Uma parceria muito produtiva que trouxe ainda muito mais recursos e feedbacks.</p></li><li><p><em>TypeScript 1.6 e 1.8</em> - Com essa versão tivemos muitas melhorias no sistema de tipos do TypeScript. Tivemos a cada release a adição de padrões JavaScript, o que proporcionou um maior suporte a bibliotecas JavaScript existentes. Muitas melhorias no compilador também foram feitas neste período.</p></li><li><p><em>TypeScript 2.0</em> - Finalmente! Agora temos um grande suporte a bibliotecas JavaScript, excelentes ferramentas, um poderoso Language Service e muito mais… vamos falar um pouco sobre as principais novidades.</p></li></ul><h2 id="Novidades-no-TypeScript-2-0"><a href="#Novidades-no-TypeScript-2-0" class="headerlink" title="Novidades no TypeScript 2.0"></a>Novidades no TypeScript 2.0</h2><p>Eu já tenho falado a um tempo sobre algumas features planejadas para esta versão. Algumas já haviam sido liberadas para teste em versões beta. Vou tentar mais uma vez destacar as principais features que trouzxeram grandes mudanças para a linguagem:</p><h3 id="Aquisicao-de-definicoes-de-tipo-os-famosos-arquivos-d-ts"><a href="#Aquisicao-de-definicoes-de-tipo-os-famosos-arquivos-d-ts" class="headerlink" title="Aquisição de definiçoes de tipo (os famosos arquivos .d.ts)"></a>Aquisição de definiçoes de tipo (os famosos arquivos .d.ts)</h3><p>Grandes ferramentas desenvolvidas pela comunidade (e eu tive a oportunidade de desenvolver uma delas) como o <a href="https://github.com/typings/typings" target="_blank" rel="noopener">Typings</a> e o <a href="https://github.com/DefinitelyTyped/tsd" target="_blank" rel="noopener">TSD</a> contribuiram bastante para o ecosistema do TypeScript ajudando milhares de desenvlvedores ao redor do munto a obter arquivos de definição para as mais diversas bibliotecas JavaScript, no entanto, existe um gerenciador de download de pacotes que já se popularizou muito entre os desenvolvedores JavaScript e nada melhor do que utilizar este mesmo gerenciador no ciclo de trabalho com TypeScript, o <a href="https://www.npmjs.com/" target="_blank" rel="noopener">npm</a>. Um esforço do time do TypeScript junto com o time do DefinitelyTyped e outros membros da comunidade trouxe ao TypeScript a capacidade de obter tipagens diretamente do npm. Isso ajuda a simplificar e muito o workflow de senvolvimento, já que, já temos uma infinidade de ferramentas diferentes que precisam ser utilizadas. Nada melhor do que tentar simplificar as coisas. O TSD e o Typings ajudaram bastante no passado, mas agora com o npm, a tendência é que o trabalho se torne mais simples e padronizado. Por exemplo, se você quiser baixar o arquivo de definição do <code>lodash</code> basta utilizar a seguinte linha de comando:</p><blockquote><p>npm install –save @types/lodash</p></blockquote><p>Neste <a href="/posts/The-Future-of-Declaration-Files">post</a> você encontra mais detalhes sobre a aquisição de arquivos de definição direto do npm.</p><h3 id="Tipos-nao-nulos"><a href="#Tipos-nao-nulos" class="headerlink" title="Tipos não nulos"></a>Tipos não nulos</h3><p>Uma das maiores causas de bug em software são falhas relacionadas a tipos nulos. É muito comum um desenvolvedor não verificar se as variáveis e/ou parâmetros estão ou não nulos antes de começar a utilizá-los. Para facilitar nossa vida temos agora a adição deste novo recurso. Em JavaScript além do valor <code>null</code> temos o <code>undefined</code> e estes dois valores se tornam a fonte do mal quando não são bem compreendidos e tratados.</p><p>Originalmente no TypeScript todos os tipos eram <code>nullables</code>, ou seja, qualquer tupo poderia arssumir um valor nulo. Agora com o novo compilador os valores null e undefined foram separados como tipos diferentes, ou seja, ao utilizar este novo recurso precisamos de forma declarativa definir se uma variável ou argumento terá o valor <code>null</code> ou <code>undefined</code>. Fazemos isso utilizando o recurso <code>union types</code>. Você pode verificar este <a href="/posts/TypeScript2-Beta-nun-nullable-types">post</a> para entender mais.</p><h3 id="Controle-de-fluxo-por-analize-de-tipos"><a href="#Controle-de-fluxo-por-analize-de-tipos" class="headerlink" title="Controle de fluxo por analize de tipos"></a>Controle de fluxo por analize de tipos</h3><p>Este não é um revcurso novo, foi inserido no TypeScript desde a versão 1.8, no entanto com a versão 2.0 este recurso foi expandido e ganhou muito mais poder, principalmente quando este é combinado com tipos <code>non-nullables</code>. Exemplo:</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params">condition: <span class="built_in">boolean</span></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> result: <span class="built_in">number</span>;</span><br><span class="line">    <span class="keyword">if</span> (condition) &#123;</span><br><span class="line">        result = computeImportantStuff();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Ops! 'result' pod nunca ter sido inicializado!</span></span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Você pode acessar este <a href="/posts/TypeScript-Type-Guards">post</a> para saber mais.</p><h3 id="Modificador-readonly"><a href="#Modificador-readonly" class="headerlink" title="Modificador readonly"></a>Modificador readonly</h3><p>Agora podemos definir membros imutaveis em TypeScript de forma muito fácil. Basta declarar as propriedades como <code>readonly</code>. Exemplo:</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> Person &#123;</span><br><span class="line">    readonly name: <span class="built_in">string</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">constructor</span>(<span class="params">name: <span class="built_in">string</span></span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (name.length &lt; <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">"Empty name!"</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Erro! 'name' é somente leitura.</span></span><br><span class="line"><span class="keyword">new</span> Person(<span class="string">"Daniel"</span>).name = <span class="string">"Dan"</span>;</span><br></pre></td></tr></table></figure><p>Lindo neh?</p><p>Existem ainda muitos outros recursos que podem ser conferidos <a href="https://github.com/Microsoft/TypeScript/wiki/What%27s-new-in-TypeScript" target="_blank" rel="noopener">aqui</a>.</p><h2 id="O-que-esperar-do-futuro"><a href="#O-que-esperar-do-futuro" class="headerlink" title="O que esperar do futuro?"></a>O que esperar do futuro?</h2><p>Muita coisa ainda está por vir. O JavaScript é uma das linguagens mais utilizadas no mundo, difícil um programador web hoje em dia não ter escrito ao menos algumas linhas de código em JavaScript. O TypeScript veio para ficar. Novas features virão, novas ferramentas e editores, e quem irá usufruir de tudo isso somos nós desenvolvedores.</p><p>Até a próxima!</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Finalmente consegui voltar a ativa depois de algum tempo sem escrever. Hoje vou falar sobre a ultima versão do TypeScript, a versão 2.0. Essa versão é o resultado de muito trabalho e esforço do time do TypeScript e da comunidade.&lt;/p&gt;
&lt;p&gt;Para começar a utilizar esta nova versão você pode baixar via npm utilizando o seguinte comando:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;npm install -g typescript@2.0&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Pronto! Agora você já está pronto para começar a explorar as novas features!&lt;/p&gt;
    
    </summary>
    
      <category term="TypeScript" scheme="http://diullei.com/categories/TypeScript/"/>
    
      <category term="TypeScript v2.0" scheme="http://diullei.com/categories/TypeScript/TypeScript-v2-0/"/>
    
    
      <category term="TypeScript" scheme="http://diullei.com/tags/TypeScript/"/>
    
  </entry>
  
  <entry>
    <title>ES6 - strings - Novos métodos</title>
    <link href="http://diullei.com/2016/07/25/ES6-strings-new-methods/"/>
    <id>http://diullei.com/2016/07/25/ES6-strings-new-methods/</id>
    <published>2016-07-24T22:00:00.000Z</published>
    <updated>2019-01-07T23:15:42.331Z</updated>
    
    <content type="html"><![CDATA[<p>O ES6 trouxe várias features legais para manipulação de strings. Hoje quero falar sobre 4 funções: <code>startsWith</code>, <code>endsWith</code>, <code>includes</code> e <code>repeat</code>.</p><p>Se você já precisou verificar o inicio ou final de um texto para validar se o mesmo inicia com algum padrão pré estabelecido você certamente já precisou escrever algum código utilizando a função <code>indexOf</code>. Exemplo:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> list = [<span class="string">'iPhone 5'</span>, <span class="string">'Moto X2'</span>, <span class="string">'iPad 2'</span>, <span class="string">'iPhone 6'</span>];</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> iphones = list.filter(<span class="function"><span class="keyword">function</span>(<span class="params">x</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// verifica se o texto inicia com "iPhone"</span></span><br><span class="line">    <span class="comment">// esse trecho de código não é nada legível</span></span><br><span class="line">    <span class="keyword">return</span> x.indexOf(<span class="string">'iPhone'</span>) === <span class="number">0</span>;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">iphones.forEach(<span class="function"><span class="keyword">function</span>(<span class="params">x</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(x);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// =&gt; iPhone 5</span></span><br><span class="line"><span class="comment">// =&gt; iPhone 6</span></span><br></pre></td></tr></table></figure><a id="more"></a><p>Note que foi necessário utilizar a função <code>indexOf</code>. Essa função retorna o número correspondente ao caracter no texto (iniciando com zero) que inicia com o padrão passado como parâmetro. No nosso caso “iPhone”. Caso o padrão não seja encontrado a função retorna o valor -1.</p><p>O que algumas pessoas fazem é adicionar “na força” um método novo ao objeto <code>string</code> para que o código fique mais legíveil:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (!<span class="built_in">String</span>.prototype.startsWith) &#123;</span><br><span class="line">    <span class="built_in">String</span>.prototype.startsWith = <span class="function"><span class="keyword">function</span>(<span class="params">searchString, position</span>) </span>&#123;</span><br><span class="line">        position = position || <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.indexOf(searchString, position) === position;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Com isso podemos reescrever o código do nosso primeiro exemplo da seguinte forma:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> list = [<span class="string">'iPhone 5'</span>, <span class="string">'Moto X2'</span>, <span class="string">'iPad 2'</span>, <span class="string">'iPhone 6'</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> iphones = list.filter(<span class="function"><span class="keyword">function</span>(<span class="params">x</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x.startsWith(<span class="string">'iPhone'</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">iphones.forEach(<span class="function"><span class="keyword">function</span>(<span class="params">x</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(x);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// =&gt; iPhone 5</span></span><br><span class="line"><span class="comment">// =&gt; iPhone 6</span></span><br></pre></td></tr></table></figure><p>Repare que com a utilizção do método “startsWith” o código ficou mais intuitivo do que o anterior.</p><h2 id="ES6-Novas-funcoes"><a href="#ES6-Novas-funcoes" class="headerlink" title="ES6 - Novas funções"></a>ES6 - Novas funções</h2><p>Com a chegada do ES6 não precisamos mais fazer essas manobras. Segue abaixo a descrição de algumas funções que foram adicionadas ao javascript:</p><h3 id="startsWith-…"><a href="#startsWith-…" class="headerlink" title="startsWith(…)"></a>startsWith(…)</h3><p>Isso mesmo, a função que acabamos de ver nos exemplos anteriores!</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">'hello'</span>.startsWith(<span class="string">'hell'</span>);</span><br><span class="line"><span class="comment">//=&gt; true</span></span><br></pre></td></tr></table></figure><h3 id="endsWith-…"><a href="#endsWith-…" class="headerlink" title="endsWith(…)"></a>endsWith(…)</h3><p>Similar a função <code>startsWith</code> só que esta verifica se o texto termina com o padrão informado:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">'hello'</span>.endsWith(<span class="string">'ello'</span>);</span><br><span class="line"><span class="comment">//=&gt; true</span></span><br></pre></td></tr></table></figure><h3 id="includes-…"><a href="#includes-…" class="headerlink" title="includes(…)"></a>includes(…)</h3><p>Utilizamos esta função para identificar se um texto contem um outro texto:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">'hello'</span>.includes(<span class="string">'ell'</span>);</span><br><span class="line"><span class="comment">//=&gt; true</span></span><br></pre></td></tr></table></figure><blockquote><p>No caso acima o texto “hello” contem uma ocorrencia do outro texto “ell”</p></blockquote><h3 id="repeat-…"><a href="#repeat-…" class="headerlink" title="repeat(…)"></a>repeat(…)</h3><p>Utilizamos o <code>repeat</code> para repetir um texto <code>n</code> vezes:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">'blah '</span>.repeat(<span class="number">3</span>);</span><br><span class="line"><span class="comment">//=&gt; "blah blah blah "</span></span><br></pre></td></tr></table></figure><p>Existem ainda outras funções no objeto <code>string</code>. Irei apresenta-las num próximo post. Até a próxima!</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;O ES6 trouxe várias features legais para manipulação de strings. Hoje quero falar sobre 4 funções: &lt;code&gt;startsWith&lt;/code&gt;, &lt;code&gt;endsWith&lt;/code&gt;, &lt;code&gt;includes&lt;/code&gt; e &lt;code&gt;repeat&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;Se você já precisou verificar o inicio ou final de um texto para validar se o mesmo inicia com algum padrão pré estabelecido você certamente já precisou escrever algum código utilizando a função &lt;code&gt;indexOf&lt;/code&gt;. Exemplo:&lt;/p&gt;
&lt;figure class=&quot;highlight javascript&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; list = [&lt;span class=&quot;string&quot;&gt;&#39;iPhone 5&#39;&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&#39;Moto X2&#39;&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&#39;iPad 2&#39;&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&#39;iPhone 6&#39;&lt;/span&gt;];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; iphones = list.filter(&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;x&lt;/span&gt;) &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// verifica se o texto inicia com &quot;iPhone&quot;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// esse trecho de código não é nada legível&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; x.indexOf(&lt;span class=&quot;string&quot;&gt;&#39;iPhone&#39;&lt;/span&gt;) === &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;iphones.forEach(&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;x&lt;/span&gt;) &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;built_in&quot;&gt;console&lt;/span&gt;.log(x);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// =&amp;gt; iPhone 5&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// =&amp;gt; iPhone 6&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="TypeScript" scheme="http://diullei.com/categories/TypeScript/"/>
    
      <category term="ES6" scheme="http://diullei.com/categories/TypeScript/ES6/"/>
    
    
      <category term="JavaScript" scheme="http://diullei.com/tags/JavaScript/"/>
    
      <category term="TypeScript" scheme="http://diullei.com/tags/TypeScript/"/>
    
      <category term="ES6" scheme="http://diullei.com/tags/ES6/"/>
    
  </entry>
  
  <entry>
    <title>ES6 - Nova sintaxe para criação de objetos</title>
    <link href="http://diullei.com/2016/07/18/Object-literal-features/"/>
    <id>http://diullei.com/2016/07/18/Object-literal-features/</id>
    <published>2016-07-17T22:00:00.000Z</published>
    <updated>2019-01-07T23:15:42.331Z</updated>
    
    <content type="html"><![CDATA[<p>Com o ES6 temos a possibilidade de criar objetos com uma sintaxe bem diferente da que estávamos acostumados até agora. Vamos tomar como exemplo a seguinte declarção:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> firstName = <span class="string">'Diulle'</span>;</span><br><span class="line"><span class="keyword">const</span> secondName = <span class="string">'Gomes'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> obj = &#123;</span><br><span class="line">    firstName: firstName,</span><br><span class="line">    secondName: secondName</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>Utilizando a nova sintaxe podemos reescrever esse trecho de código da seguinte forma:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> firstName = <span class="string">'Diulle'</span>;</span><br><span class="line"><span class="keyword">const</span> secondName = <span class="string">'Gomes'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> obj = &#123;</span><br><span class="line">    firstName,</span><br><span class="line">    secondName</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><a id="more"></a><p>Note que neste caso o nome da variável será considerado também como nome da propriedade do objeto. Existe ainda uma outra forma conhecida como “Computed property key” onde podemos passar o resultado de uma expressão na criação de uma propriedade. Veja o seguinte exemplo:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> firstName = <span class="string">'firstName'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> obj = &#123;</span><br><span class="line">    [firstName]: <span class="string">'Diullei'</span>,</span><br><span class="line">    [<span class="string">'secondName'</span>]: <span class="string">'Gomes'</span>,</span><br><span class="line">    [<span class="string">'other'</span> + <span class="string">'name'</span>]: <span class="string">'Moura'</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>Essa mesma sintaxe também pode ser aplicada par a criação de funções. Por exemplo, o seguinte trecho de códiogo:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">    myMethod: <span class="function"><span class="keyword">function</span>(<span class="params">x, y</span>) </span>&#123;</span><br><span class="line">      <span class="comment">//...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>Pode ser reescrito da seguinte forma:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">    myMethod(x, y) &#123;</span><br><span class="line">      <span class="comment">//...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>Ou assim:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">    [<span class="string">'myMethod'</span>](x, y) &#123;</span><br><span class="line">      <span class="comment">//...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>O objetivo principal dessa nova sintaxe é facilitar a utilização de <code>Symbols</code> como nome de propriedades. Exemplo:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">    * [<span class="built_in">Symbol</span>.iterator]() &#123;</span><br><span class="line">        <span class="keyword">yield</span> <span class="string">'hello'</span>;</span><br><span class="line">        <span class="keyword">yield</span> <span class="string">'world'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">const</span> x <span class="keyword">of</span> obj) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(x);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Output:</span></span><br><span class="line"><span class="comment">// hello</span></span><br><span class="line"><span class="comment">// world</span></span><br></pre></td></tr></table></figure><p>No código acima estamos criando um objeto com um generator identificado por <code>Symbol.iterator</code>. Veremos mais a fundo a utilização de <code>Symbols</code> em outros artigos.</p><p>O legal é que o <code>TypeScript</code> já suporta a utilização dessa sintaxe!</p><p>Por hoje é só. Abraços!</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Com o ES6 temos a possibilidade de criar objetos com uma sintaxe bem diferente da que estávamos acostumados até agora. Vamos tomar como exemplo a seguinte declarção:&lt;/p&gt;
&lt;figure class=&quot;highlight javascript&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;const&lt;/span&gt; firstName = &lt;span class=&quot;string&quot;&gt;&#39;Diulle&#39;&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;const&lt;/span&gt; secondName = &lt;span class=&quot;string&quot;&gt;&#39;Gomes&#39;&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;let&lt;/span&gt; obj = &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    firstName: firstName,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    secondName: secondName&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;Utilizando a nova sintaxe podemos reescrever esse trecho de código da seguinte forma:&lt;/p&gt;
&lt;figure class=&quot;highlight javascript&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;const&lt;/span&gt; firstName = &lt;span class=&quot;string&quot;&gt;&#39;Diulle&#39;&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;const&lt;/span&gt; secondName = &lt;span class=&quot;string&quot;&gt;&#39;Gomes&#39;&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;let&lt;/span&gt; obj = &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    firstName,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    secondName&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="TypeScript" scheme="http://diullei.com/categories/TypeScript/"/>
    
      <category term="TypeScript v1.4" scheme="http://diullei.com/categories/TypeScript/TypeScript-v1-4/"/>
    
      <category term="ES6" scheme="http://diullei.com/categories/TypeScript/TypeScript-v1-4/ES6/"/>
    
    
      <category term="JavaScript" scheme="http://diullei.com/tags/JavaScript/"/>
    
      <category term="TypeScript" scheme="http://diullei.com/tags/TypeScript/"/>
    
      <category term="ES6" scheme="http://diullei.com/tags/ES6/"/>
    
  </entry>
  
</feed>
